package module

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"

	"base/core/logger"
)

// Builder handles build-time module discovery and generation
type Builder struct {
	logger    logger.Logger
	appDir    string
	outputDir string
	loader    *DynamicLoader
}

// NewBuilder creates a new module builder
func NewBuilder(logger logger.Logger, appDir, outputDir string) *Builder {
	return &Builder{
		logger:    logger,
		appDir:    appDir,
		outputDir: outputDir,
		loader:    NewDynamicLoader(logger, appDir),
	}
}

// BuildModuleRegistry builds the module registry by discovering modules and generating necessary files
func (b *Builder) BuildModuleRegistry() error {
	b.logger.Info("ðŸ”¨ Building module registry")

	// Discover modules
	if err := b.loader.DiscoverModules(); err != nil {
		return fmt.Errorf("failed to discover modules: %w", err)
	}

	modules := b.loader.GetDiscoveredModules()
	if len(modules) == 0 {
		b.logger.Info("No modules found, skipping build")
		return nil
	}

	// Ensure output directory exists
	if err := os.MkdirAll(b.outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate import file
	// importFile := filepath.Join(b.outputDir, "modules_generated.go")
	// if err := b.generateModuleImports(importFile, modules); err != nil {
	// 	return fmt.Errorf("failed to generate module imports: %w", err)
	// }

	// Generate registry file
	registryFile := filepath.Join(b.outputDir, "registry_generated.go")
	if err := b.generateModuleRegistry(registryFile, modules); err != nil {
		return fmt.Errorf("failed to generate module registry: %w", err)
	}

	b.logger.Info("âœ… Module registry built successfully",
		logger.Int("modules", len(modules)),
		//	logger.String("importFile", importFile),
		logger.String("registryFile", registryFile))

	return nil
}

// generateModuleImports generates the import file for all modules
func (b *Builder) generateModuleImports(outputPath string, modules map[string]*ModuleInfo) error {
	content := `// Code generated by Base Framework module builder. DO NOT EDIT.

package main

import (
`

	// Add imports for each module
	for name := range modules {
		content += fmt.Sprintf("\t_ \"base/app/%s\"\n", name)
	}

	content += ")\n"

	return os.WriteFile(outputPath, []byte(content), 0644)
}

// generateModuleRegistry generates a registry file with module factory functions
func (b *Builder) generateModuleRegistry(outputPath string, modules map[string]*ModuleInfo) error {
	content := `// Code generated by Base Framework module builder. DO NOT EDIT.

package main

import (
	"base/core/module"
	"base/core/logger"
`

	// Add specific imports for each module
	for name := range modules {
		content += fmt.Sprintf("\t\"%s\" \"base/app/%s\"\n", name, name)
	}

	content += `
)

// initGeneratedModules initializes all auto-discovered modules
func initGeneratedModules(deps module.Dependencies) map[string]module.Module {
	modules := make(map[string]module.Module)
	
`

	// Generate module initialization code
	for name, info := range modules {
		content += fmt.Sprintf("\t// Initialize %s module\n", name)
		content += fmt.Sprintf("\tif %sModule := %s.%s(deps.DB); %sModule != nil {\n",
			name, name, info.ConstructorFn, name)
		content += fmt.Sprintf("\t\tmodules[\"%s\"] = %sModule\n", name, name)
		content += fmt.Sprintf("\t\tdeps.Logger.Debug(\"Generated module initialized\", logger.String(\"module\", \"%s\"))\n", name)
		content += "\t}\n\n"
	}

	content += `	return modules
}

// getGeneratedModuleInfo returns information about generated modules
func getGeneratedModuleInfo() map[string]map[string]any {
	return map[string]map[string]any{
`

	// Add module information
	for name, info := range modules {
		content += fmt.Sprintf("\t\t\"%s\": {\n", name)
		content += fmt.Sprintf("\t\t\t\"constructor\": \"%s\",\n", info.ConstructorFn)
		content += fmt.Sprintf("\t\t\t\"hasInit\": %t,\n", info.HasInit)
		content += fmt.Sprintf("\t\t\t\"hasMigrate\": %t,\n", info.HasMigrate)
		content += fmt.Sprintf("\t\t\t\"hasRoutes\": %t,\n", info.HasRoutes)
		content += "\t\t},\n"
	}

	content += `	}
}
`

	return os.WriteFile(outputPath, []byte(content), 0644)
}

// BuildAndCompile builds the module registry and compiles the application
func (b *Builder) BuildAndCompile() error {
	// Build module registry
	if err := b.BuildModuleRegistry(); err != nil {
		return err
	}

	// Run go mod tidy to ensure dependencies are correct
	b.logger.Info("ðŸ“¦ Running go mod tidy")
	if err := b.runCommand("go", "mod", "tidy"); err != nil {
		b.logger.Warn("go mod tidy failed", logger.String("error", err.Error()))
	}

	// Run go build to validate the generated code
	b.logger.Info("ðŸ”§ Validating generated code")
	if err := b.runCommand("go", "build", "-o", "/dev/null", "."); err != nil {
		return fmt.Errorf("build validation failed: %w", err)
	}

	b.logger.Info("âœ… Build and compilation successful")
	return nil
}

// runCommand runs a shell command in the current directory
func (b *Builder) runCommand(name string, args ...string) error {
	cmd := exec.Command(name, args...)
	cmd.Dir = filepath.Dir(b.appDir) // Run in the project root

	output, err := cmd.CombinedOutput()
	if err != nil {
		b.logger.Error("Command failed",
			logger.String("command", fmt.Sprintf("%s %v", name, args)),
			logger.String("output", string(output)),
			logger.String("error", err.Error()))
		return err
	}

	if len(output) > 0 {
		b.logger.Debug("Command output",
			logger.String("command", fmt.Sprintf("%s %v", name, args)),
			logger.String("output", string(output)))
	}

	return nil
}

// CleanGeneratedFiles removes generated files
func (b *Builder) CleanGeneratedFiles() error {
	files := []string{
		filepath.Join(b.outputDir, "modules_generated.go"),
		filepath.Join(b.outputDir, "registry_generated.go"),
	}

	for _, file := range files {
		if err := os.Remove(file); err != nil && !os.IsNotExist(err) {
			b.logger.Warn("Failed to remove generated file",
				logger.String("file", file),
				logger.String("error", err.Error()))
		}
	}

	return nil
}

// ValidateModules validates all discovered modules
func (b *Builder) ValidateModules() error {
	if err := b.loader.DiscoverModules(); err != nil {
		return err
	}

	modules := b.loader.GetDiscoveredModules()
	var errors []string

	for name := range modules {
		if err := b.loader.ValidateModule(name); err != nil {
			errors = append(errors, fmt.Sprintf("Module %s: %s", name, err.Error()))
		}
	}

	if len(errors) > 0 {
		return fmt.Errorf("module validation failed:\n%s", fmt.Sprintf("  - %s", errors))
	}

	return nil
}
