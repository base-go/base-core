
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>authors: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">base/app/authors/controller.go (76.1%)</option>
				
				<option value="file1">base/app/authors/module.go (100.0%)</option>
				
				<option value="file2">base/app/authors/service.go (80.3%)</option>
				
				<option value="file3">base/app/models/author.go (63.6%)</option>
				
				<option value="file4">base/app/models/book.go (0.0%)</option>
				
				<option value="file5">base/app/models/post.go (0.0%)</option>
				
				<option value="file6">base/core/app/authentication/controller.go (0.0%)</option>
				
				<option value="file7">base/core/app/authentication/mod.go (0.0%)</option>
				
				<option value="file8">base/core/app/authentication/model.go (100.0%)</option>
				
				<option value="file9">base/core/app/authentication/service.go (0.0%)</option>
				
				<option value="file10">base/core/app/profile/controller.go (0.0%)</option>
				
				<option value="file11">base/core/app/profile/model.go (11.1%)</option>
				
				<option value="file12">base/core/app/profile/module.go (0.0%)</option>
				
				<option value="file13">base/core/app/profile/service.go (0.0%)</option>
				
				<option value="file14">base/core/config/config.go (0.0%)</option>
				
				<option value="file15">base/core/email/default.go (0.0%)</option>
				
				<option value="file16">base/core/email/email.go (0.0%)</option>
				
				<option value="file17">base/core/email/postmark.go (0.0%)</option>
				
				<option value="file18">base/core/email/sendgrid.go (0.0%)</option>
				
				<option value="file19">base/core/email/smtp.go (0.0%)</option>
				
				<option value="file20">base/core/emitter/emitter.go (31.6%)</option>
				
				<option value="file21">base/core/helper/context.go (0.0%)</option>
				
				<option value="file22">base/core/helper/helpers.go (0.0%)</option>
				
				<option value="file23">base/core/helper/slug.go (0.0%)</option>
				
				<option value="file24">base/core/logger/init.go (0.0%)</option>
				
				<option value="file25">base/core/logger/logger.go (3.8%)</option>
				
				<option value="file26">base/core/module/app.go (0.0%)</option>
				
				<option value="file27">base/core/module/core.go (0.0%)</option>
				
				<option value="file28">base/core/module/initializer.go (0.0%)</option>
				
				<option value="file29">base/core/module/register.go (0.0%)</option>
				
				<option value="file30">base/core/storage/active_storage.go (0.0%)</option>
				
				<option value="file31">base/core/storage/local.go (0.0%)</option>
				
				<option value="file32">base/core/storage/r2.go (0.0%)</option>
				
				<option value="file33">base/core/storage/s3.go (0.0%)</option>
				
				<option value="file34">base/core/storage/types.go (11.8%)</option>
				
				<option value="file35">base/core/storage/utils.go (0.0%)</option>
				
				<option value="file36">base/core/types/datetime.go (0.0%)</option>
				
				<option value="file37">base/core/types/jwt.go (0.0%)</option>
				
				<option value="file38">base/test/test_helper.go (37.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package authors

import (
        "net/http"
        "strconv"

        "base/app/models"
        "base/core/storage"

        "github.com/gin-gonic/gin"
)

type AuthorController struct {
        Service *AuthorService
        Storage *storage.ActiveStorage
}

func NewAuthorController(service *AuthorService, storage *storage.ActiveStorage) *AuthorController <span class="cov1" title="1">{
        return &amp;AuthorController{
                Service: service,
                Storage: storage,
        }
}</span>

func (c *AuthorController) Routes(router *router.RouterGroup) <span class="cov6" title="2">{
        // Main CRUD endpoints
        router.GET("/authors", c.List)        // Paginated list
        router.GET("/authors/all", c.ListAll) // Unpaginated list
        router.GET("/authors/:id", c.Get)
        router.POST("/authors", c.Create)
        router.PUT("/authors/:id", c.Update)
        router.DELETE("/authors/:id", c.Delete)

        // File/Image attachment endpoints

        // HasMany relation endpoints
}</span>

// CreateAuthor godoc
// @Summary Create a new Author
// @Description Create a new Author with the input payload
// @Tags Author
// @Security ApiKeyAuth
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param authors body models.CreateAuthorRequest true "Create Author request"
// @Success 201 {object} models.AuthorResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /authors [post]
func (c *AuthorController) Create(ctx *router.Context) <span class="cov10" title="3">{
        var req models.CreateAuthorRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov6" title="2">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov1" title="1">item, err := c.Service.Create(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to create item: " + err.Error()})
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusCreated, item.ToResponse())</span>
}

// GetAuthor godoc
// @Summary Get a Author
// @Description Get a Author by its id
// @Tags Author
// @Security ApiKeyAuth
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param id path int true "Author id"
// @Success 200 {object} models.AuthorResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Router /authors/{id} [get]
func (c *AuthorController) Get(ctx *router.Context) <span class="cov10" title="3">{
        id, err := strconv.ParseUint(ctx.Param("id"), 10, 32)
        if err != nil </span><span class="cov1" title="1">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid id format"})
                return
        }</span>

        <span class="cov6" title="2">item, err := c.Service.GetById(uint(id))
        if err != nil </span><span class="cov1" title="1">{
                ctx.JSON(http.StatusOK, ErrorResponse{Error: "Item not found"})
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, item.ToResponse())</span>
}

// ListAuthors godoc
// @Summary List authors
// @Description Get a list of authors
// @Tags Author
// @Security ApiKeyAuth
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param page query int false "Page number"
// @Param limit query int false "Number of items per page"
// @Success 200 {object} types.PaginatedResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /authors [get]
func (c *AuthorController) List(ctx *router.Context) <span class="cov1" title="1">{
        var page, limit *int

        if pageStr := ctx.Query("page"); pageStr != "" </span><span class="cov0" title="0">{
                if pageNum, err := strconv.Atoi(pageStr); err == nil &amp;&amp; pageNum &gt; 0 </span><span class="cov0" title="0">{
                        page = &amp;pageNum
                }</span> else<span class="cov0" title="0"> {
                        ctx.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid page number"})
                        return
                }</span>
        }

        <span class="cov1" title="1">if limitStr := ctx.Query("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if limitNum, err := strconv.Atoi(limitStr); err == nil &amp;&amp; limitNum &gt; 0 </span><span class="cov0" title="0">{
                        limit = &amp;limitNum
                }</span> else<span class="cov0" title="0"> {
                        ctx.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid limit number"})
                        return
                }</span>
        }

        <span class="cov1" title="1">paginatedResponse, err := c.Service.GetAll(page, limit)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to fetch items: " + err.Error()})
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, paginatedResponse)</span>
}

// ListAllAuthors godoc
// @Summary List all authors without pagination
// @Description Get a list of all authors without pagination
// @Tags Author
// @Security ApiKeyAuth
// @Security BearerAuth
// @Accept json
// @Produce json
// @Success 200 {object} types.PaginatedResponse
// @Failure 500 {object} ErrorResponse
// @Router /authors/all [get]
func (c *AuthorController) ListAll(ctx *router.Context) <span class="cov1" title="1">{
        paginatedResponse, err := c.Service.GetAll(nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to fetch all items: " + err.Error()})
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, paginatedResponse)</span>
}

// UpdateAuthor godoc
// @Summary Update a Author
// @Description Update a Author by its id
// @Tags Author
// @Security ApiKeyAuth
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param id path int true "Author id"
// @Param authors body models.UpdateAuthorRequest true "Update Author request"
// @Success 200 {object} models.AuthorResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /authors/{id} [put]
func (c *AuthorController) Update(ctx *router.Context) <span class="cov10" title="3">{
        id, err := strconv.ParseUint(ctx.Param("id"), 10, 32)
        if err != nil </span><span class="cov1" title="1">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid id format"})
                return
        }</span>

        <span class="cov6" title="2">var req models.UpdateAuthorRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov1" title="1">item, err := c.Service.Update(uint(id), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to update item: " + err.Error()})
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, item.ToResponse())</span>
}

// DeleteAuthor godoc
// @Summary Delete a Author
// @Description Delete a Author by its id
// @Tags Author
// @Security ApiKeyAuth
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param id path int true "Author id"
// @Success 200 {object} SuccessResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /authors/{id} [delete]
func (c *AuthorController) Delete(ctx *router.Context) <span class="cov10" title="3">{
        id, err := strconv.ParseUint(ctx.Param("id"), 10, 32)
        if err != nil </span><span class="cov1" title="1">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid id format"})
                return
        }</span>

        <span class="cov6" title="2">if err := c.Service.Delete(uint(id)); err != nil </span><span class="cov1" title="1">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to delete item: " + err.Error()})
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, SuccessResponse{Message: "Item deleted successfully"})</span>
}

type ErrorResponse struct {
        Error string `json:"error"`
}

type SuccessResponse struct {
        Message string `json:"message"`
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package authors

import (
        "base/app/models"
        "base/core/module"

        "gorm.io/gorm"
)

type Module struct {
        module.DefaultModule
        DB *gorm.DB
}

func NewAuthorModule(db *gorm.DB) *Module <span class="cov10" title="4">{
        return &amp;Module{
                DB: db,
        }
}</span>

func (m *Module) Init() error <span class="cov1" title="1">{
        return nil
}</span>

func (m *Module) Migrate() error <span class="cov1" title="1">{
        return m.DB.AutoMigrate(&amp;models.Author{})
}</span>

func (m *Module) GetModels() []any <span class="cov1" title="1">{
        return []any{
                &amp;models.Author{},
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package authors

import (
        "fmt"
        "math"

        "base/app/models"
        "base/core/emitter"
        "base/core/logger"
        "base/core/storage"
        "base/core/types"

        "gorm.io/gorm"
)

const (
        CreateAuthorEvent = "authors.create"
        UpdateAuthorEvent = "authors.update"
        DeleteAuthorEvent = "authors.delete"
)

type AuthorService struct {
        DB      *gorm.DB
        Emitter *emitter.Emitter
        Storage *storage.ActiveStorage
        Logger  logger.Logger
}

func NewAuthorService(db *gorm.DB, emitter *emitter.Emitter, storage *storage.ActiveStorage, logger logger.Logger) *AuthorService <span class="cov3" title="2">{
        return &amp;AuthorService{
                DB:      db,
                Emitter: emitter,
                Storage: storage,
                Logger:  logger,
        }
}</span>

func (s *AuthorService) Create(req *models.CreateAuthorRequest) (*models.Author, error) <span class="cov6" title="5">{
        item := &amp;models.Author{
                Name:  req.Name,
                Email: req.Email,
        }

        if err := s.DB.Create(item).Error; err != nil </span><span class="cov0" title="0">{
                s.Logger.Error("failed to create author", logger.String("error", err.Error()))
                return nil, fmt.Errorf("failed to create author: %w", err)
        }</span>

        // Emit create event
        <span class="cov6" title="5">s.Emitter.Emit(CreateAuthorEvent, item)

        return s.GetById(item.Id)</span>
}

func (s *AuthorService) Update(id uint, req *models.UpdateAuthorRequest) (*models.Author, error) <span class="cov4" title="3">{
        item := &amp;models.Author{}
        if err := s.DB.First(item, id).Error; err != nil </span><span class="cov1" title="1">{
                s.Logger.Error("failed to find author for update",
                        logger.String("error", err.Error()),
                        logger.Int("id", int(id)))
                return nil, fmt.Errorf("failed to find author: %w", err)
        }</span>

        // Build updates map
        <span class="cov3" title="2">updates := make(map[string]any)
        // For string and other fields
        if req.Name != "" </span><span class="cov3" title="2">{
                updates["name"] = req.Name
        }</span>
        // For string and other fields
        <span class="cov3" title="2">if req.Email != "" </span><span class="cov3" title="2">{
                updates["email"] = req.Email
        }</span>

        <span class="cov3" title="2">if err := s.DB.Model(item).Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                s.Logger.Error("failed to update author",
                        logger.String("error", err.Error()),
                        logger.Int("id", int(id)))
                return nil, fmt.Errorf("failed to update author: %w", err)
        }</span>

        <span class="cov3" title="2">result, err := s.GetById(item.Id)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error("failed to get updated author",
                        logger.String("error", err.Error()),
                        logger.Int("id", int(id)))
                return nil, fmt.Errorf("failed to get updated author: %w", err)
        }</span>

        // Emit update event
        <span class="cov3" title="2">s.Emitter.Emit(UpdateAuthorEvent, result)

        return result, nil</span>
}

func (s *AuthorService) Delete(id uint) error <span class="cov6" title="5">{
        item := &amp;models.Author{}
        if err := s.DB.First(item, id).Error; err != nil </span><span class="cov3" title="2">{
                s.Logger.Error("failed to find author for deletion",
                        logger.String("error", err.Error()),
                        logger.Int("id", int(id)))
                return fmt.Errorf("failed to find author: %w", err)
        }</span>

        // Delete file attachments if any

        <span class="cov4" title="3">if err := s.DB.Delete(item).Error; err != nil </span><span class="cov0" title="0">{
                s.Logger.Error("failed to delete author",
                        logger.String("error", err.Error()),
                        logger.Int("id", int(id)))
                return fmt.Errorf("failed to delete author: %w", err)
        }</span>

        // Emit delete event
        <span class="cov4" title="3">s.Emitter.Emit(DeleteAuthorEvent, item)

        return nil</span>
}

func (s *AuthorService) GetById(id uint) (*models.Author, error) <span class="cov10" title="12">{
        item := &amp;models.Author{}

        query := item.Preload(s.DB)

        if err := query.First(item, id).Error; err != nil </span><span class="cov4" title="3">{
                s.Logger.Error("failed to get author",
                        logger.String("error", err.Error()),
                        logger.Int("id", int(id)))
                return nil, fmt.Errorf("failed to get author: %w", err)
        }</span>

        <span class="cov8" title="9">return item, nil</span>
}

func (s *AuthorService) GetAll(page *int, limit *int) (*types.PaginatedResponse, error) <span class="cov6" title="5">{
        var items []*models.Author
        var total int64
        query := s.DB.Model(&amp;models.Author{})
        // Set default values if nil
        defaultPage := 1
        defaultLimit := 10
        if page == nil </span><span class="cov6" title="4">{
                page = &amp;defaultPage
        }</span>
        <span class="cov6" title="5">if limit == nil </span><span class="cov6" title="4">{
                limit = &amp;defaultLimit
        }</span>

        // Get total count
        <span class="cov6" title="5">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                s.Logger.Error("failed to count authors",
                        logger.String("error", err.Error()))
                return nil, fmt.Errorf("failed to count authors: %w", err)
        }</span>

        // Apply pagination if provided
        <span class="cov6" title="5">if page != nil &amp;&amp; limit != nil </span><span class="cov6" title="5">{
                offset := (*page - 1) * *limit
                query = query.Offset(offset).Limit(*limit)
        }</span>

        // Preload relationships
        <span class="cov6" title="5">query = (&amp;models.Author{}).Preload(query)

        // Execute query
        if err := query.Find(&amp;items).Error; err != nil </span><span class="cov0" title="0">{
                s.Logger.Error("failed to get authors",
                        logger.String("error", err.Error()))
                return nil, fmt.Errorf("failed to get authors: %w", err)
        }</span>

        // Convert to response type
        <span class="cov6" title="5">responses := make([]*models.AuthorListResponse, len(items))
        for i, item := range items </span><span class="cov7" title="6">{
                responses[i] = item.ToListResponse()
        }</span>

        // Calculate total pages
        <span class="cov6" title="5">totalPages := int(math.Ceil(float64(total) / float64(*limit)))
        if totalPages == 0 </span><span class="cov0" title="0">{
                totalPages = 1
        }</span>

        <span class="cov6" title="5">return &amp;types.PaginatedResponse{
                Data: responses,
                Pagination: types.Pagination{
                        Total:      int(total),
                        Page:       *page,
                        PageSize:   *limit,
                        TotalPages: totalPages,
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package models

import (
        "time"

        "gorm.io/gorm"
)

// Author represents a author entity
type Author struct {
        Id        uint           `json:"id" gorm:"primarykey"`
        CreatedAt time.Time      `json:"created_at"`
        UpdatedAt time.Time      `json:"updated_at"`
        DeletedAt gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`
        Name      string         `json:"name"`
        Email     string         `json:"email"`
}

// TableName returns the table name for the Author model
func (item *Author) TableName() string <span class="cov5" title="4">{
        return "authors"
}</span>

// GetId returns the Id of the model
func (item *Author) GetId() uint <span class="cov0" title="0">{
        return item.Id
}</span>

// GetModelName returns the model name
func (item *Author) GetModelName() string <span class="cov0" title="0">{
        return "author"
}</span>

// AuthorListResponse represents the list view response
type AuthorListResponse struct {
        Id        uint      `json:"id"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
        Name      string    `json:"name"`
        Email     string    `json:"email"`
}

// AuthorResponse represents the detailed view response
type AuthorResponse struct {
        Id        uint           `json:"id"`
        CreatedAt time.Time      `json:"created_at"`
        UpdatedAt time.Time      `json:"updated_at"`
        DeletedAt gorm.DeletedAt `json:"deleted_at,omitempty"`
        Name      string         `json:"name"`
        Email     string         `json:"email"`
}

// CreateAuthorRequest represents the request payload for creating a Author
type CreateAuthorRequest struct {
        Name  string `json:"name" binding:"required"`
        Email string `json:"email" binding:"required"`
}

// UpdateAuthorRequest represents the request payload for updating a Author
type UpdateAuthorRequest struct {
        Name  string `json:"name,omitempty"`
        Email string `json:"email,omitempty"`
}

// ToListResponse converts the model to a list response
func (item *Author) ToListResponse() *AuthorListResponse <span class="cov7" title="7">{
        if item == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov7" title="7">return &amp;AuthorListResponse{
                Id:        item.Id,
                CreatedAt: item.CreatedAt,
                UpdatedAt: item.UpdatedAt,
                Name:      item.Name,
                Email:     item.Email,
        }</span>
}

// ToResponse converts the model to a detailed response
func (item *Author) ToResponse() *AuthorResponse <span class="cov5" title="4">{
        if item == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov5" title="4">return &amp;AuthorResponse{
                Id:        item.Id,
                CreatedAt: item.CreatedAt,
                UpdatedAt: item.UpdatedAt,
                DeletedAt: item.DeletedAt,
                Name:      item.Name,
                Email:     item.Email,
        }</span>
}

// Preload preloads all the model's relationships
func (item *Author) Preload(db *gorm.DB) *gorm.DB <span class="cov10" title="18">{
        query := db
        return query
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "time"

        "gorm.io/gorm"
)

// Book represents a book entity
type Book struct {
        Id        uint           `json:"id" gorm:"primarykey"`
        CreatedAt time.Time      `json:"created_at"`
        UpdatedAt time.Time      `json:"updated_at"`
        DeletedAt gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`
        Title     string         `json:"title"`
        Author    string         `json:"author"`
        Year      int            `json:"year"`
        Pages     int            `json:"pages"`
}

// TableName returns the table name for the Book model
func (item *Book) TableName() string <span class="cov0" title="0">{
        return "books"
}</span>

// GetId returns the Id of the model
func (item *Book) GetId() uint <span class="cov0" title="0">{
        return item.Id
}</span>

// GetModelName returns the model name
func (item *Book) GetModelName() string <span class="cov0" title="0">{
        return "book"
}</span>

// BookListResponse represents the list view response
type BookListResponse struct {
        Id        uint      `json:"id"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
        Title     string    `json:"title"`
        Author    string    `json:"author"`
        Year      int       `json:"year"`
        Pages     int       `json:"pages"`
}

// BookResponse represents the detailed view response
type BookResponse struct {
        Id        uint           `json:"id"`
        CreatedAt time.Time      `json:"created_at"`
        UpdatedAt time.Time      `json:"updated_at"`
        DeletedAt gorm.DeletedAt `json:"deleted_at,omitempty"`
        Title     string         `json:"title"`
        Author    string         `json:"author"`
        Year      int            `json:"year"`
        Pages     int            `json:"pages"`
}

// CreateBookRequest represents the request payload for creating a Book
type CreateBookRequest struct {
        Title  string `json:"title" binding:"required"`
        Author string `json:"author" binding:"required"`
        Year   int    `json:"year" binding:"required"`
        Pages  int    `json:"pages" binding:"required"`
}

// UpdateBookRequest represents the request payload for updating a Book
type UpdateBookRequest struct {
        Title  string `json:"title,omitempty"`
        Author string `json:"author,omitempty"`
        Year   int    `json:"year,omitempty"`
        Pages  int    `json:"pages,omitempty"`
}

// ToListResponse converts the model to a list response
func (item *Book) ToListResponse() *BookListResponse <span class="cov0" title="0">{
        if item == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;BookListResponse{
                Id:        item.Id,
                CreatedAt: item.CreatedAt,
                UpdatedAt: item.UpdatedAt,
                Title:     item.Title,
                Author:    item.Author,
                Year:      item.Year,
                Pages:     item.Pages,
        }</span>
}

// ToResponse converts the model to a detailed response
func (item *Book) ToResponse() *BookResponse <span class="cov0" title="0">{
        if item == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;BookResponse{
                Id:        item.Id,
                CreatedAt: item.CreatedAt,
                UpdatedAt: item.UpdatedAt,
                DeletedAt: item.DeletedAt,
                Title:     item.Title,
                Author:    item.Author,
                Year:      item.Year,
                Pages:     item.Pages,
        }</span>
}

// Preload preloads all the model's relationships
func (item *Book) Preload(db *gorm.DB) *gorm.DB <span class="cov0" title="0">{
        query := db
        return query
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "time"

        "gorm.io/gorm"
)

// Post represents a post entity
type Post struct {
        Id        uint           `json:"id" gorm:"primarykey"`
        CreatedAt time.Time      `json:"created_at"`
        UpdatedAt time.Time      `json:"updated_at"`
        DeletedAt gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`
        Title     string         `json:"title"`
        Content   string         `json:"content"`
        AuthorId  uint           `json:"author_id"`
        Author    Author         `json:"author,omitempty" gorm:"foreignKey:AuthorId"`
}

// TableName returns the table name for the Post model
func (item *Post) TableName() string <span class="cov0" title="0">{
        return "posts"
}</span>

// GetId returns the Id of the model
func (item *Post) GetId() uint <span class="cov0" title="0">{
        return item.Id
}</span>

// GetModelName returns the model name
func (item *Post) GetModelName() string <span class="cov0" title="0">{
        return "post"
}</span>

// PostListResponse represents the list view response
type PostListResponse struct {
        Id        uint      `json:"id"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
        Title     string    `json:"title"`
        Content   string    `json:"content"`
        AuthorId  uint      `json:"author_id"`
        Author    Author    `json:"author"`
}

// PostResponse represents the detailed view response
type PostResponse struct {
        Id        uint           `json:"id"`
        CreatedAt time.Time      `json:"created_at"`
        UpdatedAt time.Time      `json:"updated_at"`
        DeletedAt gorm.DeletedAt `json:"deleted_at,omitempty"`
        Title     string         `json:"title"`
        Content   string         `json:"content"`
        AuthorId  uint           `json:"author_id"`
        Author    Author         `json:"author,omitempty"`
}

// CreatePostRequest represents the request payload for creating a Post
type CreatePostRequest struct {
        Title    string `json:"title" binding:"required"`
        Content  string `json:"content" binding:"required"`
        AuthorId uint   `json:"author_id" binding:"required"`
        Author   Author `json:"author" binding:"required"`
}

// UpdatePostRequest represents the request payload for updating a Post
type UpdatePostRequest struct {
        Id       uint   `json:"id" binding:"required"`
        Title    string `json:"title,omitempty"`
        Content  string `json:"content,omitempty"`
        AuthorId uint   `json:"author_id,omitempty"`
        Author   Author `json:"author,omitempty"`
}

// ToListResponse converts the model to a list response
func (item *Post) ToListResponse() *PostListResponse <span class="cov0" title="0">{
        if item == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;PostListResponse{
                Id:        item.Id,
                CreatedAt: item.CreatedAt,
                UpdatedAt: item.UpdatedAt,
                Title:     item.Title,
                Content:   item.Content,
                AuthorId:  item.AuthorId,
                Author:    item.Author,
        }</span>
}

// ToResponse converts the model to a detailed response
func (item *Post) ToResponse() *PostResponse <span class="cov0" title="0">{
        if item == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;PostResponse{
                Id:        item.Id,
                CreatedAt: item.CreatedAt,
                UpdatedAt: item.UpdatedAt,
                DeletedAt: item.DeletedAt,
                Title:     item.Title,
                Content:   item.Content,
                AuthorId:  item.AuthorId,
                Author:    item.Author,
        }</span>
}

// Preload preloads all the model's relationships
func (item *Post) Preload(db *gorm.DB) *gorm.DB <span class="cov0" title="0">{
        query := db
        query = query.Preload("Author")
        return query
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package authentication

import (
        "base/core/email"
        "base/core/logger"
        "errors"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type AuthController struct {
        service     *AuthService
        emailSender email.Sender
        logger      logger.Logger
}

func NewAuthController(service *AuthService, emailSender email.Sender, logger logger.Logger) *AuthController <span class="cov0" title="0">{
        return &amp;AuthController{
                service:     service,
                emailSender: emailSender,
                logger:      logger,
        }
}</span>

func (c *AuthController) Routes(router *router.RouterGroup) <span class="cov0" title="0">{
        router.POST("/register", c.Register)
        router.POST("/login", c.Login)
        router.POST("/logout", c.Logout)
        router.POST("/forgot-password", c.ForgotPassword)
        router.POST("/reset-password", c.ResetPassword)
}</span>

// @Summary Register
// @Description Register user
// @Security ApiKeyAuth
// @Tags Core/Auth
// @Accept json
// @Produce json
// @Param body body RegisterRequest true "Register Request"
// @Success 201 {object} AuthResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/register [post]
func (c *AuthController) Register(ctx *router.Context) <span class="cov0" title="0">{
        var req RegisterRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov0" title="0">user, err := c.service.Register(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to register user"})
                return
        }</span>

        //        Send welcome email
        <span class="cov0" title="0">msg := email.Message{
                To:      []string{user.Email},
                From:    "no-reply@base.al",
                Subject: "Welcome to Base",
                Body:    c.getWelcomeEmailBody(user.FirstName),
                IsHTML:  true,
        }

        err = email.Send(msg)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to send welcome email",
                        logger.String("error", err.Error()),
                        logger.String("email", user.Email))
        }</span> else<span class="cov0" title="0"> {
                c.logger.Info("Welcome email sent",
                        logger.String("email", user.Email))
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusCreated, user)</span>
}

// @Summary Login
// @Description Login user
// @Security ApiKeyAuth
// @Tags Core/Auth
// @Accept json
// @Produce json
// @Param body body LoginRequest true "Login Request"
// @Success 200 {object} AuthResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/login [post]
func (c *AuthController) Login(ctx *router.Context) <span class="cov0" title="0">{
        var req LoginRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov0" title="0">response, err := c.service.Login(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "access_denied") </span><span class="cov0" title="0">{
                        // Return both the response and error when user is not an author
                        ctx.JSON(http.StatusForbidden, gin.H{
                                "error": err.Error(),
                                "data":  response,
                        })
                        return
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "invalid credentials") </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusUnauthorized, ErrorResponse{Error: err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">ctx.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Internal server error"})
                return</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, response)</span>
}

// Logout handles user logout
// @Summary Logout
// @Description Logout user
// @Security ApiKeyAuth
// @Tags Core/Auth
// @Accept json
// @Produce json
// @Success 200 {object} SuccessResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Router /auth/logout [post]
func (c *AuthController) Logout(ctx *router.Context) <span class="cov0" title="0">{
        ctx.JSON(http.StatusOK, SuccessResponse{Message: "Logout successful"})
}</span>

// @Summary Forgot Password
// @Description Request to reset password
// @Security ApiKeyAuth
// @Tags Core/Auth
// @Accept json
// @Produce json
// @Param body body ForgotPasswordRequest true "Forgot Password Request"
// @Success 200 {object} SuccessResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/forgot-password [post]
func (c *AuthController) ForgotPassword(ctx *router.Context) <span class="cov0" title="0">{
        var req ForgotPasswordRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to bind JSON in ForgotPassword", zap.Error(err))
                ctx.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.logger.Info("Processing forgot password request", zap.String("email", req.Email))

        err := c.service.ForgotPassword(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "user not found") </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNotFound, ErrorResponse{Error: "User not found"})
                }</span> else<span class="cov0" title="0"> {
                        ctx.JSON(http.StatusInternalServerError, ErrorResponse{Error: "An error occurred while processing your request"})
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, SuccessResponse{Message: "Password reset email sent"})</span>
}

// ResetPassword handles password reset requests
// @Summary Reset Password
// @Description Reset user password using token
// @Security ApiKeyAuth
// @Tags Core/Auth
// @Accept json
// @Produce json
// @Param body body ResetPasswordRequest true "Reset Password Request"
// @Success 200 {object} SuccessResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/reset-password [post]
func (c *AuthController) ResetPassword(ctx *router.Context) <span class="cov0" title="0">{
        var req ResetPasswordRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">err := c.service.ResetPassword(req.Email, req.Token, req.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, ErrInvalidToken):<span class="cov0" title="0">
                        ctx.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid or expired token"})</span>
                case errors.Is(err, ErrUserNotFound):<span class="cov0" title="0">
                        ctx.JSON(http.StatusNotFound, ErrorResponse{Error: "User not found"})</span>
                default:<span class="cov0" title="0">
                        ctx.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to reset password"})</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, SuccessResponse{Message: "Password reset successful"})</span>
}

func (c *AuthController) getWelcomeEmailBody(name string) string <span class="cov0" title="0">{
        return "&lt;h1&gt;Welcome to Base!&lt;/h1&gt;" +
                "&lt;p&gt;Hi " + name + ",&lt;/p&gt;" +
                "&lt;p&gt;Thank you for registering with our application.&lt;/p&gt;" +
                "&lt;p&gt;Best regards,&lt;br&gt;Team&lt;/p&gt;"
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package authentication

import (
        "base/core/email"
        "base/core/emitter"
        "base/core/logger"
        "base/core/module"

        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

type AuthenticationModule struct {
        module.DefaultModule
        DB          *gorm.DB
        Controller  *AuthController
        Service     *AuthService
        Logger      logger.Logger
        EmailSender email.Sender
        Emitter     *emitter.Emitter
}

func NewAuthenticationModule(db *gorm.DB, router *router.RouterGroup, emailSender email.Sender, logger logger.Logger, emitter *emitter.Emitter) module.Module <span class="cov0" title="0">{
        service := NewAuthService(db, emailSender, emitter)
        controller := NewAuthController(service, emailSender, logger)

        authModule := &amp;AuthenticationModule{
                DB:          db,
                Controller:  controller,
                Service:     service,
                Logger:      logger,
                EmailSender: emailSender,
                Emitter:     emitter,
        }

        return authModule
}</span>

func (m *AuthenticationModule) Routes(router *router.RouterGroup) <span class="cov0" title="0">{
        // Router is already /api/auth from start.go
        m.Controller.Routes(router)
}</span>

func (m *AuthenticationModule) Migrate() error <span class="cov0" title="0">{
        return m.DB.AutoMigrate(&amp;AuthUser{})
}</span>

func (m *AuthenticationModule) GetModels() []any <span class="cov0" title="0">{
        return []any{
                &amp;AuthUser{},
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package authentication

import (
        "base/core/app/profile"
        "time"
)

type AuthUser struct {
        profile.User     `gorm:"embedded"`
        LastLogin        *time.Time `gorm:"column:last_login"`
        ResetToken       string     `gorm:"column:reset_token"`
        ResetTokenExpiry *time.Time `gorm:"column:reset_token_expiry"`
}

func (AuthUser) TableName() string <span class="cov10" title="4">{
        return "users"
}</span>

type LoginEvent struct {
        User         *AuthUser
        LoginAllowed *bool
        Error        *ErrorResponse
        Response     *AuthResponse
}

// RegisterRequest represents the payload for user registration
// @Description Registration request payload
type RegisterRequest struct {
        // @Description User's first name
        FirstName string `json:"first_name" example:"John" gorm:"column:first_name"`
        // @Description User's last name
        LastName string `json:"last_name" example:"Doe" gorm:"column:last_name"`
        // @Description Username for the account
        Username string `json:"username" example:"johndoe" gorm:"column:username"`
        // @Description User's phone number
        Phone string `json:"phone" example:"+1234567890" gorm:"column:phone"`
        // @Description User's email address
        Email string `json:"email" binding:"required,email" example:"john@example.com"`
        // @Description Password for the account (minimum 8 characters)
        Password string `json:"password" binding:"required,min=8" example:"password123"`
}

type LoginRequest struct {
        Email    string `json:"email" binding:"required,email" example:"john@example.com"`
        Password string `json:"password" binding:"required" example:"password123"`
}

type ForgotPasswordRequest struct {
        Email string `json:"email" binding:"required,email" example:"john@example.com"`
}

type ResetPasswordRequest struct {
        Email       string `json:"email" binding:"required,email" example:"john@example.com"`
        Token       string `json:"token" binding:"required"`
        NewPassword string `json:"new_password" binding:"required,min=6" example:"newpassword123"`
}

type AuthResponse struct {
        profile.UserResponse
        AccessToken string      `json:"accessToken"`
        Exp         int64       `json:"exp"`
        Extend      any `json:"extend,omitempty"`
}

type ErrorResponse struct {
        Error string `json:"error"`
}

type SuccessResponse struct {
        Message string `json:"message"`
}

// VerifyOTPRequest represents the payload to verify an OTP for login
type VerifyOTPRequest struct {
        Email string `json:"email" binding:"required,email"`
        OTP   string `json:"otp" binding:"required"`
}

// SendOTPRequest represents the payload to request sending an OTP
type SendOTPRequest struct {
        Email string `json:"email" binding:"required,email"`
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package authentication

import (
        "bytes"
        "crypto/rand"
        "database/sql"
        "errors"
        "fmt"
        "sync"
        "text/template"
        "time"

        "base/core/app/profile"
        "base/core/email"
        "base/core/emitter"
        "base/core/helper"
        "base/core/types"

        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"
)

var (
        emailTemplateMutex sync.RWMutex
        emailTemplateCache *template.Template
)

// AuthService handles authentication related operations
type AuthService struct {
        db          *gorm.DB
        emailSender email.Sender
        emitter     *emitter.Emitter
}

// NewAuthService creates a new authentication service
func NewAuthService(db *gorm.DB, emailSender email.Sender, emitter *emitter.Emitter) *AuthService <span class="cov0" title="0">{
        return &amp;AuthService{
                db:          db,
                emailSender: emailSender,
                emitter:     emitter,
        }
}</span>

// validateUser checks if username or email already exists
func (s *AuthService) validateUser(email, username string) error <span class="cov0" title="0">{
        var count int64
        if err := s.db.Model(&amp;AuthUser{}).
                Where("email = ? OR username = ?", email, username).
                Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database error: %w", err)
        }</span>

        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("user already exists")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *AuthService) Register(req *RegisterRequest) (*AuthResponse, error) <span class="cov0" title="0">{
        // Validate unique constraints first
        if err := s.validateUser(req.Email, req.Username); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Hash password
        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        <span class="cov0" title="0">now := time.Now()

        user := AuthUser{
                User: profile.User{
                        Email:     req.Email,
                        Password:  string(hashedPassword),
                        FirstName: req.FirstName,
                        LastName:  req.LastName,
                        Username:  req.Username,
                        Phone:     req.Phone,
                },
                LastLogin: &amp;now,
        }

        // Start transaction
        tx := s.db.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to begin transaction: %w", tx.Error)
        }</span>

        <span class="cov0" title="0">if err := tx.Create(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                if errors.Is(err, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        return nil, errors.New("user already exists")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to create user: %w", err)</span>
        }

        <span class="cov0" title="0">if err := tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        // Generate JWT token
        <span class="cov0" title="0">token, err := helper.GenerateJWT(user.User.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        <span class="cov0" title="0">userData := types.UserData{
                Id:        user.Id,
                FirstName: user.User.FirstName,
                LastName:  user.User.LastName,
                Username:  user.Username,
                Email:     user.Email,
        }

        // Emit registration event
        if s.emitter != nil </span><span class="cov0" title="0">{
                s.emitter.Emit("user.registered", userData)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Emitter is nil in AuthService.Register; cannot emit 'user.registered' event")
        }</span>

        // Send welcome email asynchronously
        // go func() {
        //         if err := s.sendWelcomeEmail(&amp;user); err != nil {
        //                 fmt.Printf("Failed to send welcome email: %v", err)
        //         }
        // }()

        <span class="cov0" title="0">userResponse := profile.ToResponse(&amp;user.User)
        userResponse.LastLogin = now.Format(time.RFC3339)

        return &amp;AuthResponse{
                UserResponse: *userResponse,
                AccessToken:  token,
                Exp:          now.Add(24 * time.Hour).Unix(),
        }, nil</span>
}

func (s *AuthService) Login(req *LoginRequest) (*AuthResponse, error) <span class="cov0" title="0">{
        var user AuthUser
        if err := s.db.Where("email = ?", req.Email).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid credentials")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("database error: %w", err)</span>
        }

        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password)); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid credentials")
        }</span>

        // Proceed with generating token and response
        <span class="cov0" title="0">now := time.Now()
        token, err := helper.GenerateJWT(user.User.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // Create the response
        <span class="cov0" title="0">userResponse := profile.ToResponse(&amp;user.User)
        if user.LastLogin != nil </span><span class="cov0" title="0">{
                userResponse.LastLogin = user.LastLogin.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">response := &amp;AuthResponse{
                UserResponse: *userResponse,
                AccessToken:  token,
                Exp:          now.Add(24 * time.Hour).Unix(),
        }

        // Prepare the login event
        loginAllowed := true
        event := LoginEvent{
                User:         &amp;user,
                LoginAllowed: &amp;loginAllowed,
                Response:     response,
        }

        // Emit the login attempt event
        s.emitter.Emit("user.login_attempt", &amp;event)

        // Check if login was allowed after event listeners have processed it
        if !loginAllowed </span><span class="cov0" title="0">{
                if event.Error != nil </span><span class="cov0" title="0">{
                        return event.Response, errors.New(event.Error.Error)
                }</span>
                <span class="cov0" title="0">return event.Response, errors.New("not authorized")</span>
        }

        // Update last login with proper time handling
        <span class="cov0" title="0">if err := s.db.Model(&amp;user).Update("last_login", sql.NullTime{
                Time:  now,
                Valid: true,
        }).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update last login: %w", err)
        }</span>

        <span class="cov0" title="0">return response, nil</span>
}

func (s *AuthService) ForgotPassword(email string) error <span class="cov0" title="0">{
        var user AuthUser
        if err := s.db.Where("email = ?", email).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return fmt.Errorf("user not found: %w", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("database error: %w", err)</span>
        }

        <span class="cov0" title="0">token, err := generateToken()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate token: %w", err)
        }</span>
        <span class="cov0" title="0">expiry := time.Now().Add(15 * time.Minute)

        // Update reset token fields in transaction
        tx := s.db.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", tx.Error)
        }</span>

        <span class="cov0" title="0">updates := map[string]any{
                "reset_token":        token,
                "reset_token_expiry": sql.NullTime{Time: expiry, Valid: true},
        }

        if err := tx.Model(&amp;user).Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to save reset token: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.sendPasswordResetEmail(&amp;user, token); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send password reset email: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *AuthService) ResetPassword(email, token, newPassword string) error <span class="cov0" title="0">{
        var user AuthUser
        if err := s.db.Where("email = ?", email).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return fmt.Errorf("user not found: %w", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("database error: %w", err)</span>
        }

        <span class="cov0" title="0">if user.ResetToken != token </span><span class="cov0" title="0">{
                return errors.New("invalid token")
        }</span>

        <span class="cov0" title="0">if user.ResetTokenExpiry == nil || time.Now().After(*user.ResetTokenExpiry) </span><span class="cov0" title="0">{
                return errors.New("token expired")
        }</span>

        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Update password and clear reset token in transaction
        <span class="cov0" title="0">tx := s.db.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", tx.Error)
        }</span>

        <span class="cov0" title="0">updates := map[string]any{
                "password":           string(hashedPassword),
                "reset_token":        "",
                "reset_token_expiry": nil,
        }

        if err := tx.Model(&amp;user).Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to update password: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        // Send confirmation email asynchronously
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := s.sendPasswordChangedEmail(&amp;user); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to send password changed email: %v\n", err)
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

func generateToken() (string, error) <span class="cov0" title="0">{
        b := make([]byte, 32)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate random bytes: %w", err)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", b), nil</span>
}

// Email sending functions
func (s *AuthService) sendEmail(to, subject, title, content string) error <span class="cov0" title="0">{
        var cachedTemplate *template.Template
        emailTemplateMutex.RLock()
        cachedTemplate = emailTemplateCache
        emailTemplateMutex.RUnlock()

        if cachedTemplate == nil </span><span class="cov0" title="0">{
                newTemplate, err := template.New("email").Parse(emailTemplate)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error parsing email template: %w", err)
                }</span>

                <span class="cov0" title="0">emailTemplateMutex.Lock()
                emailTemplateCache = newTemplate
                emailTemplateMutex.Unlock()

                cachedTemplate = newTemplate</span>
        }

        <span class="cov0" title="0">var body bytes.Buffer
        err := cachedTemplate.Execute(&amp;body, map[string]any{
                "Title":   title,
                "Content": content,
                "Year":    time.Now().Year(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute email template: %w", err)
        }</span>

        <span class="cov0" title="0">msg := email.Message{
                To:      []string{to},
                From:    "no-reply@base.al",
                Subject: subject,
                Body:    body.String(),
                IsHTML:  true,
        }
        return s.emailSender.Send(msg)</span>
}

func (s *AuthService) sendPasswordResetEmail(user *AuthUser, token string) error <span class="cov0" title="0">{
        title := "Reset Your Base Password"
        content := fmt.Sprintf(`
                &lt;p&gt;Hi %s,&lt;/p&gt;
                &lt;p&gt;You have requested to reset your password. Use the following code to reset your password:&lt;/p&gt;
                &lt;h2&gt;%s&lt;/h2&gt;
                &lt;p&gt;This code will expire in 15 minutes.&lt;/p&gt;
                &lt;p&gt;If you didn't request a password reset, please ignore this email or contact support if you have concerns.&lt;/p&gt;
        `, user.FirstName, token)
        return s.sendEmail(user.Email, title, title, content)
}</span>

func (s *AuthService) sendPasswordChangedEmail(user *AuthUser) error <span class="cov0" title="0">{
        title := "Your Base Password Has Been Changed"
        content := fmt.Sprintf("&lt;p&gt;Hi %s,&lt;/p&gt;&lt;p&gt;Your password has been successfully changed. If you did not make this change, please contact support immediately.&lt;/p&gt;", user.FirstName)
        return s.sendEmail(user.Email, title, title, content)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package profile

import (
        "base/core/logger"
        "base/core/types"
        "errors"
        "net/http"

        "github.com/gin-gonic/gin"

        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"
)

type ProfileController struct {
        service *ProfileService
        logger  logger.Logger
}

func NewProfileController(service *ProfileService, logger logger.Logger) *ProfileController <span class="cov0" title="0">{
        return &amp;ProfileController{
                service: service,
                logger:  logger,
        }
}</span>

func (c *ProfileController) Routes(router *router.RouterGroup) <span class="cov0" title="0">{
        router.GET("/profile", c.Get)
        router.PUT("/profile", c.Update)
        router.PUT("/profile/avatar", c.UpdateAvatar)
        router.PUT("/profile/password", c.UpdatePassword)
}</span>

// @Summary Get profile from Authenticated User Token
// @Description Get profile by Bearer Token
// @Security ApiKeyAuth
// @Security BearerAuth
// @Tags Core/Profile
// @Accept json
// @Produce json
// @Success 200 {object} User
// @Failure 400 {object} types.ErrorResponse
// @Failure 404 {object} types.ErrorResponse
// @Failure 500 {object} types.ErrorResponse
// @Router /profile [get]
func (c *ProfileController) Get(ctx *router.Context) <span class="cov0" title="0">{
        id := ctx.GetUint("user_id")
        c.logger.Debug("Getting user", logger.Uint("user_id", id))
        if id == 0 </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, types.ErrorResponse{Error: "Invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">item, err := c.service.GetByID(uint(id))
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNotFound, types.ErrorResponse{Error: "User not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.logger.Error("Failed to get user",
                        logger.Uint("user_id", id))
                ctx.JSON(http.StatusInternalServerError, types.ErrorResponse{Error: "Failed to fetch user"})
                return</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, item)</span>
}

// @Summary Update profile from Authenticated User Token
// @Description Update profile by Bearer Token
// @Security ApiKeyAuth
// @Security BearerAuth
// @Tags Core/Profile
// @Accept json
// @Produce json
// @Param input body UpdateRequest true "Update Request"
// @Success 200 {object} User
// @Failure 400 {object} types.ErrorResponse
// @Failure 404 {object} types.ErrorResponse
// @Failure 500 {object} types.ErrorResponse
// @Router /profile [put]
func (c *ProfileController) Update(ctx *router.Context) <span class="cov0" title="0">{
        id := ctx.GetUint("user_id")
        if id == 0 </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, types.ErrorResponse{Error: "Invalid ID format"})
                return
        }</span>

        <span class="cov0" title="0">var req UpdateRequest
        if err := ctx.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, types.ErrorResponse{Error: "Invalid input: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">item, err := c.service.Update(uint(id), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to update user",
                        logger.Uint("user_id", id))

                ctx.JSON(http.StatusInternalServerError, types.ErrorResponse{Error: "Failed to update user: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, item)</span>
}

// @Summary Update profile avatar from Authenticated User Token
// @Description Update profile avatar by Bearer Token
// @Security ApiKeyAuth
// @Security BearerAuth
// @Tags Core/Profile
// @Accept multipart/form-data
// @Produce json
// @Param avatar formData file true "Avatar file"
// @Success 200 {object} User
// @Failure 400 {object} types.ErrorResponse
// @Failure 404 {object} types.ErrorResponse
// @Failure 500 {object} types.ErrorResponse
// @Router /profile/avatar [put]
func (c *ProfileController) UpdateAvatar(ctx *router.Context) <span class="cov0" title="0">{
        id := ctx.GetUint("user_id")
        if id == 0 </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, types.ErrorResponse{Error: "Invalid ID format"})
                return
        }</span>

        <span class="cov0" title="0">file, err := ctx.FormFile("avatar")
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, types.ErrorResponse{Error: "Failed to get avatar file: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">updatedUser, err := c.service.UpdateAvatar(ctx, uint(id), file)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to update avatar",
                        logger.Uint("user_id", id))

                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNotFound, types.ErrorResponse{Error: "User not found"})
                }</span> else<span class="cov0" title="0"> {
                        ctx.JSON(http.StatusInternalServerError, types.ErrorResponse{Error: "Failed to update avatar: " + err.Error()})
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, updatedUser)</span>
}

// @Summary Update profile password from Authenticated User Token
// @Description Update profile password by Bearer Token
// @Security ApiKeyAuth
// @Security BearerAuth
// @Tags Core/Profile
// @Accept json
// @Produce json
// @Param input body UpdatePasswordRequest true "Update Password Request"
// @Success 200 {object} User
// @Failure 400 {object} types.ErrorResponse
// @Failure 404 {object} types.ErrorResponse
// @Failure 500 {object} types.ErrorResponse
// @Router /profile/password [put]
func (c *ProfileController) UpdatePassword(ctx *router.Context) <span class="cov0" title="0">{
        id := ctx.GetUint("user_id")
        if id == 0 </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, types.ErrorResponse{Error: "Invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">var req UpdatePasswordRequest
        if err := ctx.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to bind password update request")
                ctx.JSON(http.StatusBadRequest, types.ErrorResponse{Error: "Invalid input: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if len(req.NewPassword) &lt; 6 </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, types.ErrorResponse{Error: "New password must be at least 6 characters long"})
                return
        }</span>

        <span class="cov0" title="0">err := c.service.UpdatePassword(uint(id), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to update password",
                        logger.Uint("user_id", id))

                switch </span>{
                case errors.Is(err, gorm.ErrRecordNotFound):<span class="cov0" title="0">
                        ctx.JSON(http.StatusNotFound, types.ErrorResponse{Error: "User not found"})</span>
                case errors.Is(err, bcrypt.ErrMismatchedHashAndPassword):<span class="cov0" title="0">
                        ctx.JSON(http.StatusUnauthorized, types.ErrorResponse{Error: "Current password is incorrect"})</span>
                default:<span class="cov0" title="0">
                        ctx.JSON(http.StatusInternalServerError, types.ErrorResponse{Error: "Failed to update password"})</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, types.SuccessResponse{Message: "Password updated successfully"})</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package profile

import (
        "base/core/storage"
        "time"

        "gorm.io/gorm"
)

type User struct {
        Id        uint                `gorm:"column:id;primary_key;auto_increment"`
        FirstName string              `gorm:"column:first_name;not null;size:255"`
        LastName  string              `gorm:"column:last_name;not null;size:255"`
        Username  string              `gorm:"column:username;unique;not null;size:255"`
        Phone     string              `gorm:"column:phone;unique;size:255"`
        Email     string              `gorm:"column:email;unique;not null;size:255"`
        Avatar    *storage.Attachment `gorm:"foreignKey:ModelId;references:Id"`
        Password  string              `gorm:"column:password;size:255"`
        LastLogin *time.Time          `gorm:"column:last_login"`
        CreatedAt time.Time           `gorm:"column:created_at"`
        UpdatedAt time.Time           `gorm:"column:updated_at"`
        DeletedAt gorm.DeletedAt      `gorm:"column:deleted_at"`
}

func (User) TableName() string <span class="cov10" title="8">{
        return "users"
}</span>

type CreateRequest struct {
        FirstName string `json:"first_name" binding:"required,max=255"`
        LastName  string `json:"last_name" binding:"required,max=255"`
        Username  string `json:"username" binding:"required,max=255"`
        Phone     string `json:"phone" binding:"max=255"`
        Email     string `json:"email" binding:"required,email,max=255"`
        Password  string `json:"password" binding:"required,min=8,max=255"`
}

type UpdateRequest struct {
        FirstName string `form:"first_name" binding:"max=255"`
        LastName  string `form:"last_name" binding:"max=255"`
        Username  string `form:"username" binding:"max=255"`
        Phone     string `form:"phone" binding:"max=255"`
        Email     string `form:"email" binding:"email,max=255"`
}

type UpdatePasswordRequest struct {
        OldPassword string `form:"OldPassword" binding:"required,max=255"`
        NewPassword string `form:"NewPassword" binding:"required,min=6,max=255"`
}

// Implement the Attachable interface
func (u *User) GetId() uint <span class="cov0" title="0">{
        return u.Id
}</span>

func (u *User) GetModelName() string <span class="cov0" title="0">{
        return "users"
}</span>

// UserResponse represents the API response structure
type UserResponse struct {
        Id        uint   `json:"id"`
        FirstName string `json:"first_name"`
        LastName  string `json:"last_name"`
        Username  string `json:"username"`
        Phone     string `json:"phone"`
        Email     string `json:"email"`
        AvatarURL string `json:"avatar_url"`
        LastLogin string `json:"last_login"`
}

// AvatarResponse represents the avatar in API responses
type AvatarResponse struct {
        Id       uint   `json:"id"`
        Filename string `json:"filename"`
        URL      string `json:"url"`
}

// Helper function to convert User to UserResponse
func ToResponse(user *User) *UserResponse <span class="cov0" title="0">{
        response := &amp;UserResponse{
                Id:        user.Id,
                FirstName: user.FirstName,
                LastName:  user.LastName,
                Username:  user.Username,
                Phone:     user.Phone,
                Email:     user.Email,
        }

        if user.Avatar != nil </span><span class="cov0" title="0">{
                response.AvatarURL = user.Avatar.URL
        }</span>

        <span class="cov0" title="0">if user.LastLogin != nil </span><span class="cov0" title="0">{
                response.LastLogin = user.LastLogin.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">return response</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package profile

import (
        "base/core/logger"
        "base/core/module"
        "base/core/storage"

        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

type UserModule struct {
        module.DefaultModule
        DB            *gorm.DB
        Controller    *ProfileController
        Service       *ProfileService
        Logger        logger.Logger
        ActiveStorage *storage.ActiveStorage
}

func NewUserModule(
        db *gorm.DB,
        router *router.RouterGroup,
        logger logger.Logger,
        activeStorage *storage.ActiveStorage,
) module.Module <span class="cov0" title="0">{
        // Initialize service with active storage
        service := NewProfileService(db, logger, activeStorage)
        controller := NewProfileController(service, logger)

        usersModule := &amp;UserModule{
                DB:            db,
                Controller:    controller,
                Service:       service,
                Logger:        logger,
                ActiveStorage: activeStorage,
        }

        return usersModule
}</span>

func (m *UserModule) Routes(router *router.RouterGroup) <span class="cov0" title="0">{
        m.Controller.Routes(router)
}</span>

func (m *UserModule) Migrate() error <span class="cov0" title="0">{
        err := m.DB.AutoMigrate(&amp;User{})
        if err != nil </span><span class="cov0" title="0">{
                m.Logger.Error("Migration failed", logger.String("error", err.Error()))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *UserModule) GetModels() []any <span class="cov0" title="0">{
        return []any{
                &amp;User{},
        }
}</span>

func (m *UserModule) GetModelNames() []string <span class="cov0" title="0">{
        models := m.GetModels()
        names := make([]string, len(models))
        for i, model := range models </span><span class="cov0" title="0">{
                names[i] = m.DB.Model(model).Statement.Table
        }</span>
        <span class="cov0" title="0">return names</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package profile

import (
        "base/core/logger"
        "base/core/storage"
        "context"
        "errors"
        "fmt"
        "mime/multipart"

        "go.uber.org/zap"
        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"
)

type ProfileService struct {
        db            *gorm.DB
        logger        logger.Logger
        activeStorage *storage.ActiveStorage
}

func NewProfileService(db *gorm.DB, logger logger.Logger, activeStorage *storage.ActiveStorage) *ProfileService <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                panic("db is required")</span>
        }
        <span class="cov0" title="0">if logger == nil </span><span class="cov0" title="0">{
                panic("logger is required")</span>
        }
        <span class="cov0" title="0">if activeStorage == nil </span><span class="cov0" title="0">{
                panic("activeStorage is required")</span>
        }

        // Register avatar attachment configuration
        <span class="cov0" title="0">activeStorage.RegisterAttachment("users", storage.AttachmentConfig{
                Field:             "avatar",
                Path:              "avatars",
                AllowedExtensions: []string{".jpg", ".jpeg", ".png", ".gif"},
                MaxFileSize:       5 &lt;&lt; 20, // 5MB
                Multiple:          false,
        })

        return &amp;ProfileService{
                db:            db,
                logger:        logger,
                activeStorage: activeStorage,
        }</span>
}

// Helper method to convert user to response
func (s *ProfileService) ToResponse(user *User) *UserResponse <span class="cov0" title="0">{
        return ToResponse(user)
}</span>

func (s *ProfileService) GetByID(id uint) (*UserResponse, error) <span class="cov0" title="0">{
        var user User
        if err := s.db.First(&amp;user, id).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        s.logger.Error("User not found",
                                logger.Uint("user_id", id))
                }</span> else<span class="cov0" title="0"> {
                        s.logger.Error("Database error while fetching user",

                                logger.Uint("user_id", id))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">return s.ToResponse(&amp;user), nil</span>
}

func (s *ProfileService) Update(id uint, req *UpdateRequest) (*UserResponse, error) <span class="cov0" title="0">{
        var user User
        if err := s.db.First(&amp;user, id).Error; err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to find user for update",
                        zap.Error(err),
                        zap.Uint("user_id", id))
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">if req.FirstName != "" </span><span class="cov0" title="0">{
                user.FirstName = req.FirstName
        }</span>
        <span class="cov0" title="0">if req.LastName != "" </span><span class="cov0" title="0">{
                user.LastName = req.LastName
        }</span>
        <span class="cov0" title="0">if req.Username != "" </span><span class="cov0" title="0">{
                user.Username = req.Username
        }</span>
        <span class="cov0" title="0">if req.Email != "" </span><span class="cov0" title="0">{
                user.Email = req.Email
        }</span>

        <span class="cov0" title="0">if err := s.db.Save(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to save user updates",
                        zap.Error(err),
                        zap.Uint("user_id", id))
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">return s.ToResponse(&amp;user), nil</span>
}

func (s *ProfileService) UpdateAvatar(ctx context.Context, id uint, avatarFile *multipart.FileHeader) (*UserResponse, error) <span class="cov0" title="0">{
        var user User
        if err := s.db.First(&amp;user, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Just attach the new file - cleanup is handled inside Attach
        <span class="cov0" title="0">attachment, err := s.activeStorage.Attach(&amp;user, "avatar", avatarFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to upload avatar: %w", err)
        }</span>

        // Update user's avatar
        <span class="cov0" title="0">user.Avatar = attachment
        if err := s.db.Save(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">return s.ToResponse(&amp;user), nil</span>
}

func (s *ProfileService) RemoveAvatar(ctx context.Context, id uint) (*UserResponse, error) <span class="cov0" title="0">{
        tx := s.db.Begin()
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        <span class="cov0" title="0">var user User
        if err := tx.First(&amp;user, id).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, err
        }</span>

        <span class="cov0" title="0">if user.Avatar != nil </span><span class="cov0" title="0">{
                if err := s.activeStorage.Delete(user.Avatar); err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        s.logger.Error("Failed to delete avatar",
                                zap.Error(err),
                                zap.Uint("user_id", id))
                        return nil, fmt.Errorf("failed to delete avatar: %w", err)
                }</span>
                <span class="cov0" title="0">user.Avatar = nil
                if err := tx.Save(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if err := tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.ToResponse(&amp;user), nil</span>
}

func (s *ProfileService) UpdatePassword(id uint, req *UpdatePasswordRequest) error <span class="cov0" title="0">{
        var user User
        if err := s.db.First(&amp;user, id).Error; err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to find user for password update",
                        zap.Error(err),
                        zap.Uint("user_id", id))
                return fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.OldPassword)); err != nil </span><span class="cov0" title="0">{
                s.logger.Info("Invalid old password provided",
                        zap.Uint("user_id", id))
                return bcrypt.ErrMismatchedHashAndPassword
        }</span>

        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.NewPassword), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to hash new password",
                        zap.Error(err),
                        zap.Uint("user_id", id))
                return fmt.Errorf("failed to hash password: %w", err)
        }</span>

        <span class="cov0" title="0">user.Password = string(hashedPassword)
        if err := s.db.Save(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to save new password",
                        zap.Error(err),
                        zap.Uint("user_id", id))
                return fmt.Errorf("failed to update user password: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "strings"
)

// Config holds the application configuration.
type Config struct {
        BaseURL              string
        CDN                  string
        Env                  string
        DBDriver             string
        DBUser               string
        DBPassword           string
        DBHost               string
        DBPort               string
        DBName               string
        DBPath               string
        DBURL                string
        ApiKey               string
        JWTSecret            string
        ServerAddress        string
        ServerPort           string
        CORSAllowedOrigins   []string
        Version              string
        EmailProvider        string
        EmailFromAddress     string
        SMTPHost             string
        SMTPPort             int
        SMTPUsername         string
        SMTPPassword         string
        SendGridAPIKey       string
        PostmarkServerToken  string
        PostmarkAccountToken string
        StorageProvider      string   `json:"storage_provider"`
        StoragePath          string   `json:"storage_path"`
        StorageBaseURL       string   `json:"storage_base_url"`
        StorageAPIKey        string   `json:"storage_api_key"`
        StorageAPISecret     string   `json:"storage_api_secret"`
        StorageAccountID     string   `json:"storage_account_id"`
        StorageEndpoint      string   `json:"storage_endpoint"`
        StorageRegion        string   `json:"storage_region"`
        StorageBucket        string   `json:"storage_bucket"`
        StoragePublicURL     string   `json:"storage_public_url"`
        StorageMaxSize       int64    `json:"storage_max_size"`
        StorageAllowedExt    []string `json:"storage_allowed_ext"`
}

// NewConfig returns a new Config instance with default values.
func NewConfig() *Config <span class="cov0" title="0">{
        serverAddr := getEnvWithLog("SERVER_ADDRESS", "localhost")
        serverPort := getEnvWithLog("SERVER_PORT", ":8080")
        baseURL := getEnvWithLog("APPHOST", "http://localhost")

        // Ensure port starts with :
        if serverPort != "" &amp;&amp; serverPort[0] != ':' </span><span class="cov0" title="0">{
                serverPort = ":" + serverPort
        }</span>

        // Append port to baseURL if not already present
        <span class="cov0" title="0">if !strings.Contains(baseURL, ":") || strings.HasSuffix(baseURL, "localhost") </span><span class="cov0" title="0">{
                baseURL = baseURL + serverPort
        }</span>

        <span class="cov0" title="0">config := &amp;Config{
                BaseURL:            baseURL,
                CDN:                getEnvWithLog("CDN", ""),
                Env:                getEnvWithLog("ENV", "debug"),
                DBDriver:           getEnvWithLog("DB_DRIVER", "mysql"),
                DBUser:             getEnvWithLog("DB_USER", "root"),
                DBPassword:         getEnvWithLog("DB_PASSWORD", "RockeT"),
                DBHost:             getEnvWithLog("DB_HOST", "localhost"),
                DBPort:             getEnvWithLog("DB_PORT", "3306"),
                DBName:             getEnvWithLog("DB_NAME", "mydatabase"),
                DBPath:             getEnvWithLog("DB_PATH", "test.db"),
                DBURL:              getEnvWithLog("DB_URL", ""),
                ApiKey:             getEnvWithLog("API_KEY", "test_api_key"),
                JWTSecret:          getEnvWithLog("JWT_SECRET", "secret"),
                ServerAddress:      serverAddr,
                ServerPort:         serverPort,
                CORSAllowedOrigins: strings.Split(getEnvWithLog("CORS_ALLOWED_ORIGINS", ""), ","),
                Version:            getEnvWithLog("APP_VERSION", "0.0.1"),

                EmailProvider:        getEnvWithLog("EMAIL_PROVIDER", "default"),
                EmailFromAddress:     getEnvWithLog("EMAIL_FROM_ADDRESS", "no-reply@localhost"),
                SMTPHost:             getEnvWithLog("SMTP_HOST", ""),
                SMTPUsername:         getEnvWithLog("SMTP_USERNAME", ""),
                SMTPPassword:         getEnvWithLog("SMTP_PASSWORD", ""),
                SendGridAPIKey:       getEnvWithLog("SENDGRID_API_KEY", ""),
                PostmarkServerToken:  getEnvWithLog("POSTMARK_SERVER_TOKEN", ""),
                PostmarkAccountToken: getEnvWithLog("POSTMARK_ACCOUNT_TOKEN", ""),
                StorageProvider:      getEnvWithLog("STORAGE_PROVIDER", "local"),
                StoragePath:          getEnvWithLog("STORAGE_PATH", "storage/uploads"),
                StorageBaseURL:       getEnvWithLog("STORAGE_BASE_URL", ""),
                StorageAPIKey:        getEnvWithLog("STORAGE_API_KEY", ""),
                StorageAPISecret:     getEnvWithLog("STORAGE_API_SECRET", ""),
                StorageAccountID:     getEnvWithLog("STORAGE_ACCOUNT_ID", ""),
                StorageEndpoint:      getEnvWithLog("STORAGE_ENDPOINT", ""),
                StorageRegion:        getEnvWithLog("STORAGE_REGION", "eu-central-1"),
                StorageBucket:        getEnvWithLog("STORAGE_BUCKET", "default"),
                StoragePublicURL:     getEnvWithLog("STORAGE_PUBLIC_URL", ""),
                StorageAllowedExt: strings.Split(
                        getEnvWithLog("STORAGE_ALLOWED_EXT", ".jpg,.jpeg,.png,.gif,.pdf,.doc,.docx"),
                        ",",
                ),
        }

        // Handle SMTP_PORT as an integer
        smtpPortStr := getEnvWithLog("SMTP_PORT", "587")
        smtpPort, err := strconv.Atoi(smtpPortStr)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Invalid SMTP_PORT value: %s. Using default: 587\n", smtpPortStr)
                smtpPort = 587
        }</span>
        <span class="cov0" title="0">config.SMTPPort = smtpPort

        storageSizeStr := getEnvWithLog("STORAGE_MAX_SIZE", "10485760")
        storageSize, err := strconv.ParseInt(storageSizeStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Invalid STORAGE_MAX_SIZE value: %s. Using default: 10MB\n", storageSizeStr)
                storageSize = 10 &lt;&lt; 20
        }</span>
        <span class="cov0" title="0">config.StorageMaxSize = storageSize

        return config</span>
}
func (c *Config) GetStorageConfig() map[string]any <span class="cov0" title="0">{
        return map[string]any{
                "provider":    c.StorageProvider,
                "api_key":     c.StorageAPIKey,
                "api_secret":  c.StorageAPISecret,
                "endpoint":    c.StorageEndpoint,
                "region":      c.StorageRegion,
                "bucket":      c.StorageBucket,
                "public_url":  c.StoragePublicURL,
                "base_url":    c.StorageBaseURL,
                "max_size":    c.StorageMaxSize,
                "allowed_ext": c.StorageAllowedExt,
                "path":        c.StoragePath,
                "env":         c.Env,
        }
}</span>

// getEnvWithLog returns the value of an environment variable with a fallback default value and logs the result.
func getEnvWithLog(key, fallback string) string <span class="cov0" title="0">{
        value, exists := os.LookupEnv(key)
        if exists </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return fallback</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package email

import (
        "base/core/config"
        "fmt"
)

type DefaultSender struct{}

func NewDefaultSender(cfg *config.Config) (*DefaultSender, error) <span class="cov0" title="0">{
        return &amp;DefaultSender{}, nil
}</span>

func (s *DefaultSender) Send(msg Message) error <span class="cov0" title="0">{
        fmt.Printf("Simulating email send - To: %v, From: %s, Subject: %s, IsHTML: %t\n", 
                msg.To, msg.From, msg.Subject, msg.IsHTML)

        fmt.Println("Email Content:")
        fmt.Println("-------------------")
        fmt.Println(msg.Body)
        fmt.Println("-------------------")

        return nil
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package email

import (
        "base/core/config"
        "fmt"
        "sync"
)

var (
        sender Sender
        once   sync.Once
)

type Message struct {
        To      []string
        From    string
        Subject string
        Body    string
        IsHTML  bool
}

type Sender interface {
        Send(msg Message) error
}

// Initialize sets up the email sender based on the configuration
func Initialize(cfg *config.Config) error <span class="cov0" title="0">{
        var err error
        once.Do(func() </span><span class="cov0" title="0">{
                sender, err = NewSender(cfg)
        }</span>)
        <span class="cov0" title="0">return err</span>
}

// Send sends an email using the configured email provider
func Send(msg Message) error <span class="cov0" title="0">{
        if sender == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("email sender not initialized")
        }</span>
        <span class="cov0" title="0">return sender.Send(msg)</span>
}

// NewEmailSender creates a new email sender based on the configuration
func NewSender(cfg *config.Config) (Sender, error) <span class="cov0" title="0">{
        fmt.Printf("Initializing email sender with provider: %s\n", cfg.EmailProvider)

        switch cfg.EmailProvider </span>{
        case "smtp":<span class="cov0" title="0">
                return NewSMTPSender(cfg)</span>
        case "sendgrid":<span class="cov0" title="0">
                return NewSendGridSender(cfg)</span>
        case "postmark":<span class="cov0" title="0">
                return NewPostmarkSender(cfg)</span>
        case "default":<span class="cov0" title="0">
                return NewDefaultSender(cfg)</span>
        case "":<span class="cov0" title="0">
                fmt.Println("EMAIL_PROVIDER not set, using default sender")
                return NewDefaultSender(cfg)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported email provider: %s", cfg.EmailProvider)</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package email

import (
        "base/core/config"

        "github.com/keighl/postmark"
)

type PostmarkSender struct {
        client *postmark.Client
        from   string
}

func NewPostmarkSender(cfg *config.Config) (*PostmarkSender, error) <span class="cov0" title="0">{
        client := postmark.NewClient(cfg.PostmarkServerToken, cfg.PostmarkAccountToken)
        return &amp;PostmarkSender{
                client: client,
                from:   cfg.EmailFromAddress,
        }, nil
}</span>

func (s *PostmarkSender) Send(msg Message) error <span class="cov0" title="0">{
        email := postmark.Email{
                From:     s.from,
                To:       msg.To[0],
                Subject:  msg.Subject,
                TextBody: msg.Body,
                HtmlBody: msg.Body,
        }

        if !msg.IsHTML </span><span class="cov0" title="0">{
                email.HtmlBody = ""
        }</span> else<span class="cov0" title="0"> {
                email.TextBody = ""
        }</span>

        <span class="cov0" title="0">_, err := s.client.SendEmail(email)
        return err</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package email

import (
        "base/core/config"

        "github.com/sendgrid/sendgrid-go"
        "github.com/sendgrid/sendgrid-go/helpers/mail"
)

type SendGridSender struct {
        client *sendgrid.Client
        from   string
}

func NewSendGridSender(cfg *config.Config) (*SendGridSender, error) <span class="cov0" title="0">{
        client := sendgrid.NewSendClient(cfg.SendGridAPIKey)
        return &amp;SendGridSender{
                client: client,
                from:   cfg.EmailFromAddress,
        }, nil
}</span>

func (s *SendGridSender) Send(msg Message) error <span class="cov0" title="0">{
        from := mail.NewEmail("", s.from)
        to := mail.NewEmail("", msg.To[0])
        content := mail.NewContent("text/plain", msg.Body)
        if msg.IsHTML </span><span class="cov0" title="0">{
                content = mail.NewContent("text/html", msg.Body)
        }</span>

        <span class="cov0" title="0">email := mail.NewV3MailInit(from, msg.Subject, to, content)

        _, err := s.client.Send(email)
        return err</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package email

import (
        "base/core/config"
        "fmt"
        "net/smtp"
)

type SMTPSender struct {
        host     string
        port     int
        username string
        password string
        from     string
}

func NewSMTPSender(cfg *config.Config) (*SMTPSender, error) <span class="cov0" title="0">{
        return &amp;SMTPSender{
                host:     cfg.SMTPHost,
                port:     cfg.SMTPPort,
                username: cfg.SMTPUsername,
                password: cfg.SMTPPassword,
                from:     cfg.EmailFromAddress,
        }, nil
}</span>

func (s *SMTPSender) Send(msg Message) error <span class="cov0" title="0">{
        auth := smtp.PlainAuth("", s.username, s.password, s.host)
        addr := fmt.Sprintf("%s:%d", s.host, s.port)

        var contentType string
        if msg.IsHTML </span><span class="cov0" title="0">{
                contentType = "Content-Type: text/html; charset=UTF-8"
        }</span> else<span class="cov0" title="0"> {
                contentType = "Content-Type: text/plain; charset=UTF-8"
        }</span>

        <span class="cov0" title="0">message := fmt.Sprintf("To: %s\r\nFrom: %s\r\nSubject: %s\r\n%s\r\n\r\n%s",
                msg.To[0], msg.From, msg.Subject, contentType, msg.Body)

        return smtp.SendMail(addr, auth, s.from, msg.To, []byte(message))</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package emitter

import (
        "fmt"
        "sync"
)

type Emitter struct {
        listeners map[string][]func(any)
        mutex     sync.RWMutex
}

func New() *Emitter <span class="cov3" title="2">{
        return &amp;Emitter{
                listeners: make(map[string][]func(any)),
        }
}</span>

func (e *Emitter) On(event string, listener func(any)) <span class="cov0" title="0">{
        e.mutex.Lock()
        defer e.mutex.Unlock()
        e.listeners[event] = append(e.listeners[event], listener)
}</span>

func (e *Emitter) Emit(event string, data any) <span class="cov10" title="10">{
        e.mutex.RLock()
        defer e.mutex.RUnlock()

        // Use a WaitGroup to wait for all listeners to finish
        var wg sync.WaitGroup
        for _, listener := range e.listeners[event] </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(listener func(any)) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Recovered from panic in listener for event %s: %v\n", event, r)
                                }</span>
                        }()
                        <span class="cov0" title="0">listener(data)</span>
                }(listener)
        }
        <span class="cov10" title="10">wg.Wait()</span> // Block until all listeners complete
}

func (e *Emitter) Clear() <span class="cov0" title="0">{
        e.mutex.Lock()
        defer e.mutex.Unlock()
        e.listeners = make(map[string][]func(any))
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package helper

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
)

const (
        // ContextKeyPrefix is the prefix for context keys
        ContextKeyPrefix = "base_"
)

// GetContextString retrieves a string value from the context with the given key
// The key should be provided without the base_ prefix
func GetContextString(c *router.Context, key string) string <span class="cov0" title="0">{
        // If the key doesn't have the prefix, add it
        if !strings.HasPrefix(key, ContextKeyPrefix) </span><span class="cov0" title="0">{
                key = ContextKeyPrefix + strings.ToLower(key)
        }</span>
        
        // Get the value from the context
        <span class="cov0" title="0">value, exists := c.Get(key)
        if !exists </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        // Convert to string
        <span class="cov0" title="0">strValue, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        <span class="cov0" title="0">return strValue</span>
}

// GetContextUint retrieves a uint value from the context with the given key
// The key should be provided without the base_ prefix
// Returns 0 if not found or invalid
func GetContextUint(c *router.Context, key string) uint <span class="cov0" title="0">{
        // Get the string value
        strValue := GetContextString(c, key)
        if strValue == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        
        // Convert to uint
        <span class="cov0" title="0">var uintValue uint
        _, err := fmt.Sscanf(strValue, "%d", &amp;uintValue)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        
        <span class="cov0" title="0">return uintValue</span>
}

// GetContextInt retrieves an int value from the context with the given key
// The key should be provided without the base_ prefix
// Returns 0 if not found or invalid
func GetContextInt(c *router.Context, key string) int <span class="cov0" title="0">{
        strValue := GetContextString(c, key)
        if strValue == "" </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">intValue, err := strconv.Atoi(strValue)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return intValue</span>
}

// GetContextBool retrieves a boolean value from the context with the given key
// The key should be provided without the base_ prefix
// Returns false if not found or invalid
func GetContextBool(c *router.Context, key string) bool <span class="cov0" title="0">{
        strValue := GetContextString(c, key)
        if strValue == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">strValue = strings.ToLower(strValue)
        return strValue == "true" || strValue == "1" || strValue == "yes"</span>
}

// GetContextFloat retrieves a float64 value from the context with the given key
// The key should be provided without the base_ prefix
// Returns 0 if not found or invalid
func GetContextFloat(c *router.Context, key string) float64 <span class="cov0" title="0">{
        strValue := GetContextString(c, key)
        if strValue == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        
        <span class="cov0" title="0">floatValue, err := strconv.ParseFloat(strValue, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        
        <span class="cov0" title="0">return floatValue</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package helper

import (
        "base/core/config"
        "base/core/types"

        "github.com/golang-jwt/jwt/v5"
)

// GenerateJWT is a wrapper around types.GenerateJWT for backward compatibility
func GenerateJWT(userID uint) (string, error) <span class="cov0" title="0">{
        return types.GenerateJWT(userID, nil)
}</span>

func ValidateJWT(tokenString string) (any, uint, error) <span class="cov0" title="0">{
        cfg := config.NewConfig()

        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (any, error) </span><span class="cov0" title="0">{
                return []byte(cfg.JWTSecret), nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                userID := uint(claims["user_id"].(float64))

                return nil, userID, nil
        }</span>

        <span class="cov0" title="0">return nil, 0, jwt.ErrSignatureInvalid</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package helper

import (
        "fmt"

        "github.com/gosimple/slug"
)

// SlugHelper provides methods for generating and validating slugs
type SlugHelper struct{}

// NewSlugHelper creates a new instance of SlugHelper
func NewSlugHelper() *SlugHelper <span class="cov0" title="0">{
        return &amp;SlugHelper{}
}</span>

// Normalize ensures the slug is properly formatted
// If customSlug is provided, it will be used as the base for the slug
// Otherwise, name will be used to generate a slug
func (h *SlugHelper) Normalize(name string, customSlug string, lang string) string <span class="cov0" title="0">{
        if customSlug != "" </span><span class="cov0" title="0">{
                // If a custom slug is provided, use it but ensure it's properly formatted
                return slug.MakeLang(customSlug, lang)
        }</span>

        // Generate slug from name
        <span class="cov0" title="0">return slug.MakeLang(name, lang)</span>
}

// GenerateUniqueSlug generates a unique slug based on the given base slug and a function to check if a slug exists
// The existsFunc should return true if the slug already exists, and false otherwise
func (h *SlugHelper) GenerateUniqueSlug(baseSlug string, existsFunc func(string) (bool, error)) (string, error) <span class="cov0" title="0">{
        // First check if the base slug is available
        exists, err := existsFunc(baseSlug)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // If the base slug is available, use it
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return baseSlug, nil
        }</span>

        // Otherwise, find an available slug by adding a sequential number
        <span class="cov0" title="0">uniqueSlug := baseSlug
        for i := 2; ; i++ </span><span class="cov0" title="0">{
                uniqueSlug = fmt.Sprintf("%s-%d", baseSlug, i)
                exists, err = existsFunc(uniqueSlug)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        return uniqueSlug, nil
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package logger

import (
        "os"
        "path/filepath"
)

var defaultLogger Logger

// Initialize sets up the default logger
func Initialize(env string) error <span class="cov0" title="0">{
        config := Config{
                Environment: env,
                LogPath:     filepath.Join("logs"),
                Level:       "info",
        }

        // Override log level from environment if set
        if level := os.Getenv("LOG_LEVEL"); level != "" </span><span class="cov0" title="0">{
                config.Level = level
        }</span>

        // Override log path from environment if set
        <span class="cov0" title="0">if path := os.Getenv("LOG_PATH"); path != "" </span><span class="cov0" title="0">{
                config.LogPath = path
        }</span>

        <span class="cov0" title="0">logger, err := NewLogger(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defaultLogger = logger
        return nil</span>
}

// GetLogger returns the default logger instance
func GetLogger() Logger <span class="cov0" title="0">{
        if defaultLogger == nil </span><span class="cov0" title="0">{
                // If logger is not initialized, create a development logger
                logger, _ := NewLogger(Config{
                        Environment: "development",
                        Level:       "info",
                })
                defaultLogger = logger
        }</span>
        <span class="cov0" title="0">return defaultLogger</span>
}

// Default logger methods for convenience
func Info(msg string, fields ...Field) <span class="cov0" title="0">{
        GetLogger().Info(msg, fields...)
}</span>

func Debug(msg string, fields ...Field) <span class="cov0" title="0">{
        GetLogger().Debug(msg, fields...)
}</span>

func Warn(msg string, fields ...Field) <span class="cov0" title="0">{
        GetLogger().Warn(msg, fields...)
}</span>

func Error(msg string, fields ...Field) <span class="cov0" title="0">{
        GetLogger().Error(msg, fields...)
}</span>

func Fatal(msg string, fields ...Field) <span class="cov0" title="0">{
        GetLogger().Fatal(msg, fields...)
}</span>

func With(fields ...Field) Logger <span class="cov0" title="0">{
        return GetLogger().With(fields...)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package logger

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// Logger is our custom logger interface that wraps the actual logging implementation
type Logger interface {
        Info(msg string, fields ...Field)
        Error(msg string, fields ...Field)
        Debug(msg string, fields ...Field)
        Warn(msg string, fields ...Field)
        Fatal(msg string, fields ...Field)
        With(fields ...Field) Logger
        GetZapLogger() *zap.Logger
}

// Field represents a log field
type Field = zapcore.Field

// Config holds the logger configuration
type Config struct {
        Environment string // "development" or "production"
        LogPath     string // Path to log directory
        Level       string // "debug", "info", "warn", "error", "fatal"
}

// ZapLogger implements the Logger interface using zap
type ZapLogger struct {
        logger *zap.Logger
}

// timeEncoder encodes the time as RFC3339Nano
func timeEncoder(t time.Time, enc zapcore.PrimitiveArrayEncoder) <span class="cov0" title="0">{
        enc.AppendString(t.Format(time.RFC3339Nano))
}</span>

// NewLogger creates a new logger based on the configuration
func NewLogger(config Config) (Logger, error) <span class="cov0" title="0">{
        var cfg zap.Config

        // Set default level if not specified
        level := zap.NewAtomicLevel()
        if err := level.UnmarshalText([]byte(config.Level)); err != nil </span><span class="cov0" title="0">{
                level.SetLevel(zapcore.InfoLevel)
        }</span>

        <span class="cov0" title="0">if config.Environment == "development" </span><span class="cov0" title="0">{
                cfg = zap.NewDevelopmentConfig()
        }</span> else<span class="cov0" title="0"> {
                cfg = zap.NewProductionConfig()
        }</span>

        <span class="cov0" title="0">cfg.EncoderConfig.EncodeTime = timeEncoder

        // Create log directory if it doesn't exist
        if err := os.MkdirAll(config.LogPath, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't create log directory: %w", err)
        }</span>

        // Set up log file
        <span class="cov0" title="0">logFile := filepath.Join(config.LogPath, "app.log")
        f, err := os.OpenFile(logFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't open log file: %w", err)
        }</span>

        // Create logger with file and console output
        <span class="cov0" title="0">encoder := zapcore.NewJSONEncoder(cfg.EncoderConfig)

        // Custom console encoder config
        consoleConfig := zap.NewDevelopmentEncoderConfig()
        consoleConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
        consoleConfig.EncodeTime = func(t time.Time, enc zapcore.PrimitiveArrayEncoder) </span><span class="cov0" title="0">{
                // Add blue color to timestamp
                enc.AppendString(fmt.Sprintf("\033[36m%s\033[0m", t.Format("2006-01-02 15:04:05")))
        }</span>
        <span class="cov0" title="0">consoleConfig.EncodeCaller = func(caller zapcore.EntryCaller, enc zapcore.PrimitiveArrayEncoder) </span><span class="cov0" title="0">{
                // Add gray/dim color to file path
                enc.AppendString(fmt.Sprintf("\033[2m%s\033[0m", caller.TrimmedPath()))
        }</span>
        <span class="cov0" title="0">consoleConfig.EncodeLevel = func(l zapcore.Level, enc zapcore.PrimitiveArrayEncoder) </span><span class="cov0" title="0">{
                switch l </span>{
                case zapcore.InfoLevel:<span class="cov0" title="0">
                        enc.AppendString("\033[34m  INFO \033[0m")</span>  // Blue
                case zapcore.WarnLevel:<span class="cov0" title="0">
                        enc.AppendString("\033[33m  WARN \033[0m")</span>  // Yellow
                case zapcore.ErrorLevel:<span class="cov0" title="0">
                        enc.AppendString("\033[31m ERROR\033[0m")</span>  // Red
                case zapcore.DebugLevel:<span class="cov0" title="0">
                        enc.AppendString("\033[35m DEBUG\033[0m")</span>  // Purple
                case zapcore.FatalLevel:<span class="cov0" title="0">
                        enc.AppendString("\033[31m\033[1m FATAL\033[0m")</span>  // Bold Red
                default:<span class="cov0" title="0">
                        enc.AppendString(l.String())</span>
                }
        }
        <span class="cov0" title="0">consoleConfig.ConsoleSeparator = "  "
        consoleEncoder := zapcore.NewConsoleEncoder(consoleConfig)

        // Create multi-writer core
        core := zapcore.NewTee(
                zapcore.NewCore(
                        encoder,
                        zapcore.AddSync(f),
                        level,
                ),
                zapcore.NewCore(
                        consoleEncoder,
                        zapcore.AddSync(os.Stdout),
                        level,
                ),
        )
        logger := zap.New(core, zap.AddCaller(), zap.AddCallerSkip(1))

        return &amp;ZapLogger{logger: logger}, nil</span>
}

// NewLoggerFromZap creates a new Logger from an existing zap.Logger
func NewLoggerFromZap(zapLogger *zap.Logger) Logger <span class="cov0" title="0">{
        return &amp;ZapLogger{
                logger: zapLogger,
        }
}</span>

// GetZapLogger returns the underlying zap logger
func (l *ZapLogger) GetZapLogger() *zap.Logger <span class="cov0" title="0">{
        return l.logger
}</span>

// Field creation helpers
func String(key string, value string) Field <span class="cov10" title="6">{
        return zap.String(key, value)
}</span>

func Int(key string, value int) Field <span class="cov10" title="6">{
        return zap.Int(key, value)
}</span>

func Int64(key string, value int64) Field <span class="cov0" title="0">{
        return zap.Int64(key, value)
}</span>

func Uint(key string, value uint) Field <span class="cov0" title="0">{
        return zap.Uint(key, value)
}</span>

func Uint64(key string, value uint64) Field <span class="cov0" title="0">{
        return zap.Uint64(key, value)
}</span>

func Float64(key string, value float64) Field <span class="cov0" title="0">{
        return zap.Float64(key, value)
}</span>

func Float32(key string, value float32) Field <span class="cov0" title="0">{
        return zap.Float32(key, value)
}</span>

func Bool(key string, value bool) Field <span class="cov0" title="0">{
        return zap.Bool(key, value)
}</span>

func Any(key string, value any) Field <span class="cov0" title="0">{
        return zap.Any(key, value)
}</span>

// Logger interface implementation
func (l *ZapLogger) Info(msg string, fields ...Field) <span class="cov0" title="0">{
        l.logger.Info(msg, fields...)
}</span>

func (l *ZapLogger) Error(msg string, fields ...Field) <span class="cov0" title="0">{
        l.logger.Error(msg, fields...)
}</span>

func (l *ZapLogger) Debug(msg string, fields ...Field) <span class="cov0" title="0">{
        l.logger.Debug(msg, fields...)
}</span>

func (l *ZapLogger) Warn(msg string, fields ...Field) <span class="cov0" title="0">{
        l.logger.Warn(msg, fields...)
}</span>

func (l *ZapLogger) Fatal(msg string, fields ...Field) <span class="cov0" title="0">{
        l.logger.Fatal(msg, fields...)
}</span>

func (l *ZapLogger) With(fields ...Field) Logger <span class="cov0" title="0">{
        return &amp;ZapLogger{logger: l.logger.With(fields...)}
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package module

import (
        "fmt"
)

// AppModuleProvider defines the interface for providing app modules
type AppModuleProvider interface {
        GetAppModules(deps Dependencies) map[string]Module
}

// AppOrchestrator handles the orchestration of app modules
type AppOrchestrator struct {
        initializer *Initializer
        provider    AppModuleProvider
}

// NewAppOrchestrator creates a new app module orchestrator
func NewAppOrchestrator(initializer *Initializer, provider AppModuleProvider) *AppOrchestrator <span class="cov0" title="0">{
        return &amp;AppOrchestrator{
                initializer: initializer,
                provider:    provider,
        }
}</span>

// InitializeAppModules initializes all app modules using the provider
func (ao *AppOrchestrator) InitializeAppModules(deps Dependencies) ([]Module, error) <span class="cov0" title="0">{
        deps.Logger.Info(" Starting app modules initialization")
        
        // Get the modules from the provider (from app/init.go)
        modules := ao.provider.GetAppModules(deps)
        
        if len(modules) == 0 </span><span class="cov0" title="0">{
                deps.Logger.Info("No app modules to initialize")
                return []Module{}, nil
        }</span>
        
        // Initialize them using the generic initializer
        <span class="cov0" title="0">initializedModules := ao.initializer.Initialize(modules, deps)
        
        deps.Logger.Info(fmt.Sprintf(" App modules initialization complete (%d modules)", len(initializedModules)))
        return initializedModules, nil</span>
}</pre>
		
		<pre class="file" id="file27" style="display: none">package module

import (
        "fmt"

        "base/core/logger"

        "github.com/gin-gonic/gin"
)

// CoreModuleProvider defines the interface for providing core modules
type CoreModuleProvider interface {
        GetCoreModules(deps Dependencies) map[string]Module
}

// CoreOrchestrator handles the orchestration of core modules
type CoreOrchestrator struct {
        initializer *Initializer
        provider    CoreModuleProvider
        authRouter  *router.RouterGroup
}

// NewCoreOrchestrator creates a new core module orchestrator
func NewCoreOrchestrator(initializer *Initializer, provider CoreModuleProvider, authRouter *router.RouterGroup) *CoreOrchestrator <span class="cov0" title="0">{
        return &amp;CoreOrchestrator{
                initializer: initializer,
                provider:    provider,
                authRouter:  authRouter,
        }
}</span>

// InitializeCoreModules initializes all core modules using the provider
func (co *CoreOrchestrator) InitializeCoreModules(deps Dependencies) ([]Module, error) <span class="cov0" title="0">{
        deps.Logger.Info("  Starting core modules initialization")

        // Get the modules from the provider (from core/app/init.go)
        modules := co.provider.GetCoreModules(deps)

        if len(modules) == 0 </span><span class="cov0" title="0">{
                deps.Logger.Info("No core modules to initialize")
                return []Module{}, nil
        }</span>

        // Initialize them using a custom core initializer that handles auth routing
        <span class="cov0" title="0">initializedModules := co.initializeCoreModules(modules, deps)

        deps.Logger.Info(fmt.Sprintf(" Core modules initialization complete (%d modules)", len(initializedModules)))
        return initializedModules, nil</span>
}

// initializeCoreModules initializes core modules with special handling for auth modules
func (co *CoreOrchestrator) initializeCoreModules(modules map[string]Module, deps Dependencies) []Module <span class="cov0" title="0">{
        var initializedModules []Module

        for name, mod := range modules </span><span class="cov0" title="0">{
                deps.Logger.Info("Initializing core module", logger.String("module", name))

                // Register module
                if err := RegisterModule(name, mod); err != nil </span><span class="cov0" title="0">{
                        deps.Logger.Error("Failed to register core module",
                                logger.String("module", name),
                                logger.String("error", err.Error()))
                        continue</span>
                }

                // Initialize
                <span class="cov0" title="0">if initModule, ok := mod.(interface{ Init() error }); ok </span><span class="cov0" title="0">{
                        if err := initModule.Init(); err != nil </span><span class="cov0" title="0">{
                                deps.Logger.Error("Failed to initialize core module",
                                        logger.String("module", name),
                                        logger.String("error", err.Error()))
                                continue</span>
                        }
                }

                // Migrate
                <span class="cov0" title="0">if migrator, ok := mod.(interface{ Migrate() error }); ok </span><span class="cov0" title="0">{
                        if err := migrator.Migrate(); err != nil </span><span class="cov0" title="0">{
                                deps.Logger.Error("Failed to migrate core module",
                                        logger.String("module", name),
                                        logger.String("error", err.Error()))
                                continue</span>
                        }
                }

                // Setup routes with special handling for auth modules
                <span class="cov0" title="0">if routeModule, ok := mod.(interface{ Routes(*router.RouterGroup) }); ok </span><span class="cov0" title="0">{
                        // Use AuthRouter for auth modules, protected Router for others
                        if name == "authentication" || name == "authorization" </span><span class="cov0" title="0">{
                                routeModule.Routes(co.authRouter)
                        }</span> else<span class="cov0" title="0"> {
                                routeModule.Routes(deps.Router)
                        }</span>
                }

                <span class="cov0" title="0">initializedModules = append(initializedModules, mod)
                deps.Logger.Info("Core module initialized successfully", logger.String("module", name))</span>
        }

        <span class="cov0" title="0">return initializedModules</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package module

import (
        "base/core/config"
        "base/core/email"
        "base/core/emitter"
        "base/core/logger"
        "base/core/storage"

        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

// Dependencies contains all dependencies that can be injected into modules
type Dependencies struct {
        DB          *gorm.DB
        Router      *router.RouterGroup
        Logger      logger.Logger
        Emitter     *emitter.Emitter
        Storage     *storage.ActiveStorage
        EmailSender email.Sender
        Config      *config.Config
}

// Initializer handles module initialization logic
type Initializer struct {
        logger logger.Logger
}

// NewInitializer creates a new module initializer
func NewInitializer(logger logger.Logger) *Initializer <span class="cov0" title="0">{
        return &amp;Initializer{
                logger: logger,
        }
}</span>

// Initialize initializes a map of modules with dependencies
func (mi *Initializer) Initialize(modules map[string]Module, deps Dependencies) []Module <span class="cov0" title="0">{
        var initializedModules []Module

        for name, mod := range modules </span><span class="cov0" title="0">{
                mi.logger.Info("Initializing module", logger.String("module", name))

                // Register module
                if err := RegisterModule(name, mod); err != nil </span><span class="cov0" title="0">{
                        mi.logger.Error("Failed to register module",
                                logger.String("module", name),
                                logger.String("error", err.Error()))
                        continue</span>
                }

                // Initialize
                <span class="cov0" title="0">if initModule, ok := mod.(interface{ Init() error }); ok </span><span class="cov0" title="0">{
                        if err := initModule.Init(); err != nil </span><span class="cov0" title="0">{
                                mi.logger.Error("Failed to initialize module",
                                        logger.String("module", name),
                                        logger.String("error", err.Error()))
                                continue</span>
                        }
                }

                // Migrate
                <span class="cov0" title="0">if migrator, ok := mod.(interface{ Migrate() error }); ok </span><span class="cov0" title="0">{
                        if err := migrator.Migrate(); err != nil </span><span class="cov0" title="0">{
                                mi.logger.Error("Failed to migrate module",
                                        logger.String("module", name),
                                        logger.String("error", err.Error()))
                                continue</span>
                        }
                }

                // Setup routes
                <span class="cov0" title="0">if routeModule, ok := mod.(interface{ Routes(*router.RouterGroup) }); ok </span><span class="cov0" title="0">{
                        routeModule.Routes(deps.Router)
                }</span>

                <span class="cov0" title="0">initializedModules = append(initializedModules, mod)
                mi.logger.Info("Module initialized successfully", logger.String("module", name))</span>
        }

        <span class="cov0" title="0">return initializedModules</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package module

import (
        "fmt"
        "reflect"
        "sync"

        "gorm.io/gorm"
)

// Module defines the common interface that all modules must implement.
type Module interface {
        Init() error
        Migrate() error
        GetModels() []any
}

// DefaultModule provides a default implementation for the Module interface.
type DefaultModule struct{}

// Translatable is an interface that modules can implement to define translatable fields
type Translatable interface {
        TranslatedFields() []string
}

func (DefaultModule) Init() error <span class="cov0" title="0">{
        return nil // Default implementation does nothing
}</span>

func (DefaultModule) Migrate() error <span class="cov0" title="0">{
        return nil // Default implementation does nothing
}</span>

func (DefaultModule) Routes() {<span class="cov0" title="0">
        // Default implementation does nothing
}</span>
func (DefaultModule) GetModels() []any <span class="cov0" title="0">{
        return nil
}</span>

// Seeder is an interface that modules can implement to seed the database.
type Seeder interface {
        Seed(*gorm.DB) error
}

var (
        // modulesRegistry stores all registered modules. The key is the module name.
        modulesRegistry = make(map[string]Module)
        lock            sync.RWMutex
)

// RegisterModule registers a module under a unique name. It returns an error
// if the module is already registered under that name.
func RegisterModule(name string, module Module) error <span class="cov0" title="0">{
        lock.Lock()
        defer lock.Unlock()
        if _, exists := modulesRegistry[name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("error: Module already registered: %s", name)
        }</span>
        <span class="cov0" title="0">modulesRegistry[name] = module
        fmt.Printf("Successfully registered module: %s\n", name)
        return nil</span>
}

// GetModule retrieves a module by its name.
func GetModule(name string) (Module, error) <span class="cov0" title="0">{
        lock.RLock()
        defer lock.RUnlock()
        module, exists := modulesRegistry[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error: Module not found: %s", name)
        }</span>
        <span class="cov0" title="0">return module, nil</span>
}

// GetAllModules retrieves a copy of the registry map, protecting it from modifications.
func GetAllModules() map[string]Module <span class="cov0" title="0">{
        lock.RLock()
        defer lock.RUnlock()
        copy := make(map[string]Module, len(modulesRegistry))
        for key, value := range modulesRegistry </span><span class="cov0" title="0">{
                copy[key] = value
        }</span>
        <span class="cov0" title="0">return copy</span>
}

// HasMethod checks if a method is implemented by a module.
func HasMethod(module Module, methodName string) bool <span class="cov0" title="0">{
        moduleType := reflect.TypeOf(module)
        _, exists := moduleType.MethodByName(methodName)
        return exists
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package storage

import (
        "fmt"
        "mime/multipart"
        "os"
        "path/filepath"
        "strings"

        "gorm.io/gorm"
)

func NewActiveStorage(db *gorm.DB, config Config) (*ActiveStorage, error) <span class="cov0" title="0">{
        var provider Provider
        var err error

        // Get current working directory
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get working directory: %w", err)
        }</span>

        // If path is relative, make it absolute using cwd
        <span class="cov0" title="0">storagePath := config.Path
        if !filepath.IsAbs(storagePath) </span><span class="cov0" title="0">{
                storagePath = filepath.Join(cwd, storagePath)
        }</span>

        <span class="cov0" title="0">switch strings.ToLower(config.Provider) </span>{
        case "local":<span class="cov0" title="0">
                provider, err = NewLocalProvider(LocalConfig{
                        BasePath: storagePath,
                        BaseURL:  config.BaseURL,
                })</span>
        case "s3":<span class="cov0" title="0">
                provider, err = NewS3Provider(S3Config{
                        APIKey:          config.APIKey,
                        APISecret:       config.APISecret,
                        AccessKeyID:     config.APIKey,
                        AccessKeySecret: config.APISecret,
                        AccountID:       config.AccountID,
                        Endpoint:        config.Endpoint,
                        Bucket:          config.Bucket,
                        BaseURL:         config.BaseURL,
                        Region:          config.Region,
                })</span>
        case "r2":<span class="cov0" title="0">
                provider, err = NewR2Provider(R2Config{
                        AccessKeyID:     config.APIKey,
                        AccessKeySecret: config.APISecret,
                        AccountID:       config.AccountID,
                        Bucket:          config.Bucket,
                        BaseURL:         config.BaseURL,
                        CDN:             config.CDN,
                })</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported storage provider: %s", config.Provider)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize storage provider: %w", err)
        }</span>

        <span class="cov0" title="0">as := &amp;ActiveStorage{
                db:          db,
                provider:    provider,
                defaultPath: storagePath,
                configs:     make(map[string]map[string]AttachmentConfig),
        }

        // Auto-migrate the Attachment model
        if err := db.AutoMigrate(&amp;Attachment{}); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to migrate attachments table: %w", err)
        }</span>

        <span class="cov0" title="0">return as, nil</span>
}

func (as *ActiveStorage) RegisterAttachment(modelName string, config AttachmentConfig) <span class="cov0" title="0">{
        if as.configs[modelName] == nil </span><span class="cov0" title="0">{
                as.configs[modelName] = make(map[string]AttachmentConfig)
        }</span>
        <span class="cov0" title="0">as.configs[modelName][config.Field] = config</span>
}

func (as *ActiveStorage) Attach(model Attachable, field string, file *multipart.FileHeader) (*Attachment, error) <span class="cov0" title="0">{
        // Get config for model
        config, err := as.getConfig(model.GetModelName(), field)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate file
        <span class="cov0" title="0">if err := as.validateFile(file, config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create attachment record
        <span class="cov0" title="0">attachment := &amp;Attachment{
                ModelType: model.GetModelName(),
                ModelId:   model.GetId(),
                Field:     field,
                Filename:  file.Filename,
                Size:      file.Size,
        }

        // Upload file using provider
        result, err := as.provider.Upload(file, UploadConfig{
                AllowedExtensions: config.AllowedExtensions,
                MaxFileSize:       config.MaxFileSize,
                UploadPath:        filepath.Join(config.Path, model.GetModelName(), field),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update attachment with upload result
        <span class="cov0" title="0">attachment.Path = result.Path
        attachment.URL = as.provider.GetURL(result.Path)

        // Save attachment record
        if err := as.db.Create(attachment).Error; err != nil </span><span class="cov0" title="0">{
                // Try to delete uploaded file if record creation fails
                _ = as.provider.Delete(result.Path)
                return nil, err
        }</span>

        <span class="cov0" title="0">return attachment, nil</span>
}

func (as *ActiveStorage) Delete(attachment *Attachment) error <span class="cov0" title="0">{
        if err := as.provider.Delete(attachment.Path); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return as.db.Delete(attachment).Error</span>
}

func (as *ActiveStorage) getConfig(modelName, field string) (AttachmentConfig, error) <span class="cov0" title="0">{
        modelConfigs, ok := as.configs[modelName]
        if !ok </span><span class="cov0" title="0">{
                return AttachmentConfig{}, fmt.Errorf("no attachment config found for model %s", modelName)
        }</span>

        <span class="cov0" title="0">config, ok := modelConfigs[field]
        if !ok </span><span class="cov0" title="0">{
                return AttachmentConfig{}, fmt.Errorf("no attachment config found for field %s in model %s", field, modelName)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

func (as *ActiveStorage) validateFile(file *multipart.FileHeader, config AttachmentConfig) error <span class="cov0" title="0">{
        if file.Size &gt; config.MaxFileSize </span><span class="cov0" title="0">{
                return fmt.Errorf("file size exceeds maximum allowed size of %d bytes", config.MaxFileSize)
        }</span>

        <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(file.Filename))
        if len(config.AllowedExtensions) &gt; 0 &amp;&amp; !strings.Contains(strings.Join(config.AllowedExtensions, ","), ext) </span><span class="cov0" title="0">{
                return fmt.Errorf("file extension %s is not allowed", ext)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package storage

import (
        "fmt"
        "io"
        "mime/multipart"
        "os"
        "path/filepath"
)

// LocalConfig holds configuration for local storage
type LocalConfig struct {
        BasePath string
        BaseURL  string
}

type localProvider struct {
        basePath string
        baseURL  string
}

func NewLocalProvider(config LocalConfig) (Provider, error) <span class="cov0" title="0">{
        // Create base directory if it doesn't exist
        if err := os.MkdirAll(config.BasePath, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create base directory: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;localProvider{
                basePath: config.BasePath,
                baseURL:  config.BaseURL,
        }, nil</span>
}

func (p *localProvider) Upload(file *multipart.FileHeader, config UploadConfig) (*UploadResult, error) <span class="cov0" title="0">{
        // Create upload directory
        uploadPath := filepath.Join(p.basePath, config.UploadPath)
        if err := os.MkdirAll(uploadPath, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create upload directory: %w", err)
        }</span>

        // Generate unique filename
        <span class="cov0" title="0">filename := generateUniqueFilename(file.Filename)
        dst := filepath.Join(uploadPath, filename)

        // Open source file
        src, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open source file: %w", err)
        }</span>
        <span class="cov0" title="0">defer src.Close()

        // Create destination file
        out, err := os.Create(dst)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create destination file: %w", err)
        }</span>
        <span class="cov0" title="0">defer out.Close()

        // Copy file
        if _, err = io.Copy(out, src); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to copy file: %w", err)
        }</span>

        <span class="cov0" title="0">relativePath := filepath.Join(config.UploadPath, filename)

        return &amp;UploadResult{
                Filename: filename,
                Path:     relativePath,
                Size:     file.Size,
        }, nil</span>
}

func (p *localProvider) Delete(path string) error <span class="cov0" title="0">{
        fullPath := filepath.Join(p.basePath, path)
        return os.Remove(fullPath)
}</span>

func (p *localProvider) GetURL(path string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s", p.baseURL, path)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package storage

import (
        "fmt"
        "mime/multipart"
        "strings"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/s3"
)

// R2Config holds configuration for Cloudflare R2 storage
type R2Config struct {
        AccessKeyID     string
        AccessKeySecret string
        AccountID       string
        Bucket          string
        BaseURL         string
        CDN             string
}

type r2Provider struct {
        client   *s3.S3
        bucket   string
        endpoint string
        baseURL  string
        cdn      string
}

func NewR2Provider(config R2Config) (Provider, error) <span class="cov0" title="0">{
        // R2 endpoint format: https://&lt;account_id&gt;.r2.cloudflarestorage.com
        endpoint := fmt.Sprintf("https://%s.r2.cloudflarestorage.com", config.AccountID)

        sess, err := session.NewSession(&amp;aws.Config{
                Credentials:      credentials.NewStaticCredentials(config.AccessKeyID, config.AccessKeySecret, ""),
                Endpoint:         aws.String(endpoint),
                Region:           aws.String("auto"), // R2 uses 'auto' as region
                S3ForcePathStyle: aws.Bool(false),    // R2 requires this to be false
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create R2 session: %w", err)
        }</span>

        // Create S3 client with the correct API version
        <span class="cov0" title="0">s3Config := &amp;aws.Config{
                S3ForcePathStyle: aws.Bool(false),
        }
        client := s3.New(sess, s3Config)

        return &amp;r2Provider{
                client:   client,
                bucket:   config.Bucket,
                endpoint: endpoint,
                baseURL:  config.BaseURL,
                cdn:      config.CDN,
        }, nil</span>
}

func (p *r2Provider) Upload(file *multipart.FileHeader, config UploadConfig) (*UploadResult, error) <span class="cov0" title="0">{
        // Open source file
        src, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open source file: %w", err)
        }</span>
        <span class="cov0" title="0">defer src.Close()

        // Generate unique filename
        filename := generateUniqueFilename(file.Filename)
        key := fmt.Sprintf("%s/%s", config.UploadPath, filename)

        // Upload to R2
        _, err = p.client.PutObject(&amp;s3.PutObjectInput{
                Bucket:      aws.String(p.bucket),
                Key:         aws.String(key),
                Body:        src,
                ContentType: aws.String(file.Header.Get("Content-Type")),
                // Note: R2 doesn't support ACL, so we remove the ACL setting
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to upload to R2: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;UploadResult{
                Filename: filename,
                Path:     key,
                Size:     file.Size,
        }, nil</span>
}

func (p *r2Provider) Delete(path string) error <span class="cov0" title="0">{
        _, err := p.client.DeleteObject(&amp;s3.DeleteObjectInput{
                Bucket: aws.String(p.bucket),
                Key:    aws.String(path),
        })
        return err
}</span>

func (p *r2Provider) GetURL(path string) string <span class="cov0" title="0">{
        // Always prefer CDN for R2 storage
        if p.cdn != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s/%s", strings.TrimRight(p.cdn, "/"), path)
        }</span>
        // Fallback to BaseURL if CDN is not configured
        <span class="cov0" title="0">if p.baseURL != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s/%s", strings.TrimRight(p.baseURL, "/"), path)
        }</span>
        // Last resort: use R2 URL
        <span class="cov0" title="0">return fmt.Sprintf("https://%s/%s/%s", p.endpoint, p.bucket, path)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package storage

import (
        "fmt"
        "mime/multipart"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/s3"
)

// S3Config holds configuration for S3 storage
type S3Config struct {
        APIKey          string
        APISecret       string
        AccessKeyID     string
        AccessKeySecret string
        AccountID       string
        Endpoint        string
        Bucket          string
        BaseURL         string
        Region          string
}

type s3Provider struct {
        client   *s3.S3
        bucket   string
        endpoint string
        baseURL  string
}

func NewS3Provider(config S3Config) (Provider, error) <span class="cov0" title="0">{
        endpoint := config.Endpoint
        if endpoint == "" </span><span class="cov0" title="0">{
                endpoint = "s3.amazonaws.com"
        }</span>

        <span class="cov0" title="0">sess, err := session.NewSession(&amp;aws.Config{
                Credentials:      credentials.NewStaticCredentials(config.AccessKeyID, config.AccessKeySecret, ""),
                Endpoint:         aws.String(endpoint),
                Region:           aws.String(config.Region),
                S3ForcePathStyle: aws.Bool(true),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create session: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;s3Provider{
                client:   s3.New(sess),
                bucket:   config.Bucket,
                endpoint: endpoint,
                baseURL:  config.BaseURL,
        }, nil</span>
}

func (p *s3Provider) Upload(file *multipart.FileHeader, config UploadConfig) (*UploadResult, error) <span class="cov0" title="0">{
        // Open source file
        src, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open source file: %w", err)
        }</span>
        <span class="cov0" title="0">defer src.Close()

        // Generate unique filename
        filename := generateUniqueFilename(file.Filename)
        key := fmt.Sprintf("%s/%s", config.UploadPath, filename)

        // Upload to S3
        _, err = p.client.PutObject(&amp;s3.PutObjectInput{
                Bucket: aws.String(p.bucket),
                Key:    aws.String(key),
                Body:   src,
                ACL:    aws.String("public-read"),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to upload to S3: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;UploadResult{
                Filename: filename,
                Path:     key,
                Size:     file.Size,
        }, nil</span>
}

func (p *s3Provider) Delete(path string) error <span class="cov0" title="0">{
        _, err := p.client.DeleteObject(&amp;s3.DeleteObjectInput{
                Bucket: aws.String(p.bucket),
                Key:    aws.String(path),
        })
        return err
}</span>

func (p *s3Provider) GetURL(path string) string <span class="cov0" title="0">{
        return fmt.Sprintf("https://%s/%s/%s", p.endpoint, p.bucket, path)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package storage

import (
        "database/sql/driver"
        "encoding/json"
        "fmt"
        "mime/multipart"
        "net/textproto"
        "os"

        "time"

        "gorm.io/gorm"
)

// Attachment represents a file attachment
type Attachment struct {
        Id        uint      `json:"id" gorm:"primaryKey"`
        ModelType string    `json:"model_type" gorm:"index"`
        ModelId   uint      `json:"model_id" gorm:"index"`
        Field     string    `json:"field" gorm:"index"`
        Filename  string    `json:"filename"`
        Path      string    `json:"path"`
        Size      int64     `json:"size"`
        URL       string    `json:"url"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// Value implements the driver.Valuer interface
func (a *Attachment) Value() (driver.Value, error) <span class="cov10" title="8">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov10" title="8">return json.Marshal(a)</span>
}

// Scan implements the sql.Scanner interface
func (a *Attachment) Scan(value any) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *a = Attachment{}
                return nil
        }</span>

        <span class="cov0" title="0">var bytes []byte
        switch v := value.(type) </span>{
        case []byte:<span class="cov0" title="0">
                bytes = v</span>
        case string:<span class="cov0" title="0">
                bytes = []byte(v)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("failed to unmarshal JSONB value: %v", value)</span>
        }

        <span class="cov0" title="0">return json.Unmarshal(bytes, &amp;a)</span>
}

// AsFileHeader converts an Attachment to a multipart.FileHeader
func (a *Attachment) AsFileHeader() (*multipart.FileHeader, error) <span class="cov0" title="0">{
        file, err := os.Open(a.Path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        return &amp;multipart.FileHeader{
                Filename: a.Filename,
                Size:     a.Size,
                Header:   textproto.MIMEHeader{"Content-Type": []string{"application/octet-stream"}},
        }, nil</span>
}

// AttachmentConfig holds configuration for file attachments
type AttachmentConfig struct {
        Field             string
        Path              string
        AllowedExtensions []string
        MaxFileSize       int64
        Multiple          bool
}

// Config holds storage service configuration
type Config struct {
        Provider  string
        Path      string
        BaseURL   string
        APIKey    string
        APISecret string
        AccountID string
        Endpoint  string
        Bucket    string
        CDN       string
        Region    string
}

// Attachable interface for models that can have attachments
type Attachable interface {
        GetId() uint
        GetModelName() string
}

// Provider interface for storage providers
type Provider interface {
        Upload(file *multipart.FileHeader, config UploadConfig) (*UploadResult, error)
        Delete(path string) error
        GetURL(path string) string
}

// ActiveStorage handles file storage operations
type ActiveStorage struct {
        db          *gorm.DB
        provider    Provider
        defaultPath string
        configs     map[string]map[string]AttachmentConfig
}

// UploadConfig holds configuration for file uploads
type UploadConfig struct {
        AllowedExtensions []string
        MaxFileSize       int64
        UploadPath        string
}

// UploadResult holds the result of a file upload
type UploadResult struct {
        Filename string
        Path     string
        Size     int64
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package storage

import (
        "fmt"
        "path/filepath"
        "regexp"
        "strings"
        "time"
)

// Patterns for filename sanitization
var (
        illegalCharsPattern = regexp.MustCompile(`[^a-zA-Z0-9\-\.]`)
        multiDashPattern    = regexp.MustCompile(`-+`)
)

// slugify converts a string to a URL-friendly slug
func slugify(s string) string <span class="cov0" title="0">{
        // Convert to lowercase and replace illegal characters with dash
        s = strings.ToLower(s)
        s = illegalCharsPattern.ReplaceAllString(s, "-")
        // Replace multiple dashes with single dash
        s = multiDashPattern.ReplaceAllString(s, "-")
        // Trim dashes from ends
        return strings.Trim(s, "-")
}</span>

// generateUniqueFilename generates a unique filename
func generateUniqueFilename(originalName string) string <span class="cov0" title="0">{
        ext := filepath.Ext(originalName)
        name := strings.TrimSuffix(originalName, ext)
        timestamp := time.Now().UnixNano()
        return fmt.Sprintf("%s-%d%s", slugify(name), timestamp, ext)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package types

import (
        "database/sql/driver"
        "fmt"
        "strings"
        "time"
)

// DateTime is a custom type for handling time values with flexible parsing
type DateTime struct {
        time.Time
}

// UnmarshalJSON implements the json.Unmarshaler interface
func (dt *DateTime) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        s := strings.Trim(string(b), "\"")
        if s == "null" || s == "" </span><span class="cov0" title="0">{
                dt.Time = time.Time{}
                return nil
        }</span>

        // Try different time formats in order of preference
        <span class="cov0" title="0">t, err := time.Parse(time.RFC3339, s)
        if err == nil </span><span class="cov0" title="0">{
                dt.Time = t
                return nil
        }</span>

        // Try other formats if RFC3339 fails
        <span class="cov0" title="0">formats := []string{
                "2006-01-02T15:04:05-0700", // Without colon in timezone
                "2006-01-02T15:04:05Z",     // UTC
                "2006-01-02T15:04:05",      // No timezone
                "2006-01-02 15:04:05",      // MySQL format
                "2006-01-02",               // Just date
        }

        for _, format := range formats </span><span class="cov0" title="0">{
                if t, err := time.Parse(format, s); err == nil </span><span class="cov0" title="0">{
                        dt.Time = t
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("cannot parse time: %v. Expected format: RFC3339 (e.g., 2006-01-02T15:04:05Z07:00) or YYYY-MM-DD", err)</span>
}

// MarshalJSON implements the json.Marshaler interface
func (dt DateTime) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if dt.Time.IsZero() </span><span class="cov0" title="0">{
                return []byte("null"), nil
        }</span>
        <span class="cov0" title="0">return []byte(fmt.Sprintf("\"%s\"", dt.Time.Format(time.RFC3339))), nil</span>
}

// Value implements the driver.Valuer interface for database operations
func (dt DateTime) Value() (driver.Value, error) <span class="cov0" title="0">{
        if dt.Time.IsZero() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return dt.Time, nil</span>
}

// Scan implements the sql.Scanner interface for database operations
func (dt *DateTime) Scan(value any) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                dt.Time = time.Time{}
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case time.Time:<span class="cov0" title="0">
                dt.Time = v
                return nil</span>
        case []byte:<span class="cov0" title="0">
                formats := []string{
                        "2006-01-02 15:04:05",     // MySQL datetime
                        "2006-01-02 15:04:05.000", // MySQL datetime with milliseconds
                        "2006-01-02",              // Date only
                }

                var lastErr error
                for _, format := range formats </span><span class="cov0" title="0">{
                        if t, err := time.Parse(format, string(v)); err == nil </span><span class="cov0" title="0">{
                                dt.Time = t
                                return nil
                        }</span> else<span class="cov0" title="0"> {
                                lastErr = err
                        }</span>
                }
                <span class="cov0" title="0">return lastErr</span>
        case string:<span class="cov0" title="0">
                if t, err := time.Parse("2006-01-02 15:04:05", v); err == nil </span><span class="cov0" title="0">{
                        dt.Time = t
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("cannot parse time string: %v", v)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("cannot scan type %T into DateTime", value)</span>
        }
}

// String implements the Stringer interface
func (dt DateTime) String() string <span class="cov0" title="0">{
        if dt.Time.IsZero() </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return dt.Time.Format(time.RFC3339)</span>
}

// Now returns the current time as DateTime
func Now() DateTime <span class="cov0" title="0">{
        return DateTime{Time: time.Now()}
}</span>

// IsZero reports whether the DateTime represents the zero time instant
func (dt DateTime) IsZero() bool <span class="cov0" title="0">{
        return dt.Time.IsZero()
}</span>

// Format returns a textual representation of the time value formatted according to the layout
func (dt DateTime) Format(layout string) string <span class="cov0" title="0">{
        return dt.Time.Format(layout)
}</span>

// Add returns the time t+d
func (dt DateTime) Add(d time.Duration) DateTime <span class="cov0" title="0">{
        return DateTime{Time: dt.Time.Add(d)}
}</span>

// Sub returns the duration t-u
func (dt DateTime) Sub(u DateTime) time.Duration <span class="cov0" title="0">{
        return dt.Time.Sub(u.Time)
}</span>

// Before reports whether the time instant t is before u
func (dt DateTime) Before(u DateTime) bool <span class="cov0" title="0">{
        return dt.Time.Before(u.Time)
}</span>

// After reports whether the time instant t is after u
func (dt DateTime) After(u DateTime) bool <span class="cov0" title="0">{
        return dt.Time.After(u.Time)
}</span>

// Equal reports whether t and u represent the same time instant
func (dt DateTime) Equal(u DateTime) bool <span class="cov0" title="0">{
        return dt.Time.Equal(u.Time)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package types

import (
        "base/core/config"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// GenerateJWT creates a new JWT token for the given user ID
func GenerateJWT(userID uint, extend any) (string, error) <span class="cov0" title="0">{
        token := jwt.New(jwt.SigningMethodHS256)
        cfg := config.NewConfig()

        claims := token.Claims.(jwt.MapClaims)
        claims["user_id"] = userID
        claims["exp"] = time.Now().Add(time.Hour * 24).Unix()
        claims["extend"] = extend

        tokenString, err := token.SignedString([]byte(cfg.JWTSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return tokenString, nil</span>
}

// ValidateJWT validates a JWT token and returns the user ID
func ValidateJWT(tokenString string) (uint, error) <span class="cov0" title="0">{
        cfg := config.NewConfig()

        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (any, error) </span><span class="cov0" title="0">{
                return []byte(cfg.JWTSecret), nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                userID := uint(claims["user_id"].(float64))
                return userID, nil
        }</span>

        <span class="cov0" title="0">return 0, jwt.ErrSignatureInvalid</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package test

import (
        "base/core/app/authentication"
        "base/core/app/profile"
        "base/core/email"
        "base/core/logger"
        "fmt"
        "os"
        "testing"

        "go.uber.org/zap"
        "golang.org/x/crypto/bcrypt"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
)

// TestHelper provides Rails-style test utilities
type TestHelper struct {
        DB     *gorm.DB
        Logger *MockLogger
}

// SetupTest initializes test environment (Rails-style setup)
func SetupTest(t *testing.T) *TestHelper <span class="cov7" title="4">{
        // Set test environment
        os.Setenv("GIN_MODE", "test")

        // Create in-memory SQLite database for testing
        db, err := gorm.Open(sqlite.Open(":memory:"), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to connect to test database: %v", err)
        }</span>

        // Auto-migrate tables
        <span class="cov7" title="4">err = db.AutoMigrate(&amp;profile.User{}, &amp;authentication.AuthUser{})
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to migrate test database: %v", err)
        }</span>

        <span class="cov7" title="4">return &amp;TestHelper{
                DB:     db,
                Logger: &amp;MockLogger{},
        }</span>
}

// TeardownTest cleans up test environment (Rails-style teardown)
func (h *TestHelper) TeardownTest() <span class="cov7" title="4">{
        // Clean up database
        if h.DB != nil </span><span class="cov7" title="4">{
                sqlDB, _ := h.DB.DB()
                if sqlDB != nil </span><span class="cov7" title="4">{
                        sqlDB.Close()
                }</span>
        }
}

// CreateTestUser creates a test user with unique email and phone (Rails-style factory)
func (h *TestHelper) CreateTestUser(email, username, phone string) *profile.User <span class="cov0" title="0">{
        hashedPassword, _ := bcrypt.GenerateFromPassword([]byte("testpassword123"), bcrypt.DefaultCost)

        user := &amp;profile.User{
                FirstName: "Test",
                LastName:  "User",
                Username:  username,
                Email:     email,
                Password:  string(hashedPassword),
                Phone:     phone,
        }

        h.DB.Create(user)
        return user
}</span>

// CreateTestAuthUser creates a test auth user (Rails-style factory)
func (h *TestHelper) CreateTestAuthUser(email, username, phone string) *authentication.AuthUser <span class="cov0" title="0">{
        hashedPassword, _ := bcrypt.GenerateFromPassword([]byte("testpassword123"), bcrypt.DefaultCost)

        authUser := &amp;authentication.AuthUser{
                User: profile.User{
                        FirstName: "Auth",
                        LastName:  "User",
                        Username:  username,
                        Email:     email,
                        Password:  string(hashedPassword),
                        Phone:     phone,
                },
        }

        h.DB.Create(authUser)
        return authUser
}</span>

// MockEmailSender provides a simple mock for email sending
type MockEmailSender struct {
        ShouldFail bool
}

func (m *MockEmailSender) Send(msg email.Message) error <span class="cov0" title="0">{
        if m.ShouldFail </span><span class="cov0" title="0">{
                return fmt.Errorf("mock email send failure")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// MockLogger provides a simple mock for logging
type MockLogger struct{}

func (m *MockLogger) Info(msg string, fields ...logger.Field) {<span class="cov0" title="0">
        // Mock implementation - do nothing
}</span>

func (m *MockLogger) Error(msg string, fields ...logger.Field) {<span class="cov10" title="6">
        // Mock implementation - do nothing
}</span>

func (m *MockLogger) Debug(msg string, fields ...logger.Field) {<span class="cov0" title="0">
        // Mock implementation - do nothing
}</span>

func (m *MockLogger) Warn(msg string, fields ...logger.Field) {<span class="cov0" title="0">
        // Mock implementation - do nothing
}</span>

func (m *MockLogger) Fatal(msg string, fields ...logger.Field) {<span class="cov0" title="0">
        // Mock implementation - do nothing
}</span>

func (m *MockLogger) With(fields ...logger.Field) logger.Logger <span class="cov0" title="0">{
        // Mock implementation - return self
        return m
}</span>

func (m *MockLogger) GetZapLogger() *zap.Logger <span class="cov0" title="0">{
        // Mock implementation - return nil
        return nil
}</span>

// MockActiveStorage provides a simple mock for storage operations
type MockActiveStorage struct{}

func (m *MockActiveStorage) Store(filename string, data []byte) (string, error) <span class="cov0" title="0">{
        // Mock implementation - return fake URL
        return "http://example.com/fake-file.jpg", nil
}</span>

func (m *MockActiveStorage) Delete(url string) error <span class="cov0" title="0">{
        // Mock implementation - just return nil
        return nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
